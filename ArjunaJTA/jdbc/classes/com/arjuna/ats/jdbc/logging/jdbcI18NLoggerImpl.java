/*
 * JBoss, Home of Professional Open Source
 * Copyright 2010, Red Hat, Inc. and/or its affiliates,
 * and individual contributors as indicated by the @author tags.
 * See the copyright.txt in the distribution for a
 * full listing of individual contributors.
 * This copyrighted material is made available to anyone wishing to use,
 * modify, copy, or redistribute it subject to the terms and conditions
 * of the GNU Lesser General Public License, v. 2.1.
 * This program is distributed in the hope that it will be useful, but WITHOUT A
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
 * PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details.
 * You should have received a copy of the GNU Lesser General Public License,
 * v.2.1 along with this distribution; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
 * MA  02110-1301, USA.
 *
 * (C) 2010,
 * @author JBoss, by Red Hat.
 */
package com.arjuna.ats.jdbc.logging;

import org.jboss.logging.Logger;

import java.text.MessageFormat;

import static org.jboss.logging.Logger.Level.*;

/**
 * i18n log messages for the jdbc module.
 * This class is autogenerated. Don't mess with it.
 *
 * @author Jonathan Halliday (jonathan.halliday@redhat.com) 2010-06
 */
public class jdbcI18NLoggerImpl implements jdbcI18NLogger {

	private final Logger logger;

	jdbcI18NLoggerImpl(Logger logger) {
		this.logger = logger;
	}

	public String get_aborterror() {
		return "ARJUNA-17001 Rollback not allowed by transaction service.";
	}

	public String get_alreadyassociated() {
		return "ARJUNA-17002 Connection is already associated with a different transaction! Obtain a new connection for this transaction.";
	}

	public String get_alreadyassociatedcheck() {
		return "ARJUNA-17003 Checking transaction and found that this connection is already associated with a different transaction! Obtain a new connection for this transaction.";
	}

	public String get_autocommit() {
		return "ARJUNA-17004 AutoCommit is not allowed by the transaction service.";
	}

	public String get_closeerror() {
		return "ARJUNA-17005 An error occurred during close:";
	}

	public String get_closeerrorinvalidtx(String arg0) {
		return MessageFormat.format("ARJUNA-17006 Invalid transaction during close {0}", arg0);
	}

	public void warn_closingconnection(String arg0) {
		logger.logv(WARN, "ARJUNA-17007 Connection will be closed now. Indications are that this db does not allow multiple connections in the same transaction {0}", arg0);
	}

	public void info_closingconnectionnull(String arg0) {
		logger.logv(INFO, "ARJUNA-17008 No modifier information found for db. Connection will be closed immediately {0}", arg0);
	}

	public String get_commiterror() {
		return "ARJUNA-17009 Commit not allowed by transaction service.";
	}

	public String get_conniniterror() {
		return "ARJUNA-17010 JDBC2 connection initialisation problem";
	}

	public String get_delisterror() {
		return "ARJUNA-17011 Delist of resource failed.";
	}

	public void warn_drcdest(Throwable arg0) {
		logger.logv(WARN, arg0, "ARJUNA-17013 Caught exception", (Object)null);
	}

	public String get_dynamicerror() {
		return "ARJUNA-17016 No dynamic class specified!";
	}

	public String get_enlistfailed() {
		return "ARJUNA-17017 enlist of resource failed";
	}

	public void warn_getmoderror(Throwable arg0) {
		logger.logv(WARN, arg0, "ARJUNA-17018 Failed to get modifier for driver:", (Object)null);
	}

	public String get_inactivetransaction() {
		return "ARJUNA-17020 Transaction is not active on the thread!";
	}

	public String get_infoerror() {
		return "ARJUNA-17021 Could not get transaction information.";
	}

	public void warn_isolationlevelfailset(String arg0, Throwable arg1) {
		logger.logv(WARN, arg1, "ARJUNA-17024 {0} - failed to set isolation level", arg0);
	}

	public String get_jndierror() {
		return "ARJUNA-17025 Could not resolve JNDI XADataSource";
	}

	public String get_nojdbcimple(String arg0) {
		return MessageFormat.format("ARJUNA-17026 Can't load ConnectionImple class {0}", arg0);
	}

	public void warn_recovery_basic_initexp(Throwable arg0) {
		logger.logv(WARN, arg0, "ARJUNA-17027 An exception occurred during initialisation.", (Object)null);
	}

	public void warn_recovery_basic_xarec(String arg0) {
		logger.logv(WARN, "ARJUNA-17028 {0} could not find information for connection!", arg0);
	}

	public void warn_recovery_xa_initexp(Throwable arg0) {
		logger.logv(WARN, arg0, "ARJUNA-17029 An exception occurred during initialisation.", (Object)null);
	}

	public String get_releasesavepointerror() {
		return "ARJUNA-17031 rollback(Savepoint) not allowed inside distributed tx.";
	}

	public void warn_rollbackerror(String arg0) {
		logger.logv(WARN, "ARJUNA-17032 {0} - could not mark transaction rollback", arg0);
	}

	public String get_rollbacksavepointerror() {
		return "ARJUNA-17033 rollback(Savepoint) not allowed inside distributed tx.";
	}

	public String get_setreadonly() {
		return "ARJUNA-17034 Cannot set readonly when within a transaction!";
	}

	public String get_setsavepointerror() {
		return "ARJUNA-17035 setSavepoint not allowed inside distributed tx.";
	}

	public String get_xa_recjndierror() {
		return "ARJUNA-17037 Could not resolve JNDI XADataSource";
	}
}
