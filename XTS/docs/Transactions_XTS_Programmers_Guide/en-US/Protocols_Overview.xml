<?xml version='1.0' encoding='utf-8' ?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [
<!ENTITY % BOOK_ENTITIES SYSTEM "Transactions_XTS_Programmers_Guide.ent">
%BOOK_ENTITIES;
]>
<chapter>
  
  <title>Overview of Protocols Used by XTS</title>

  <indexterm><primary>WS-Coordination</primary><secondary>WS-C</secondary></indexterm>
  <indexterm><primary>WS-Atomic Transaction</primary><secondary>WS-AT</secondary></indexterm>
  <indexterm><primary>activation</primary></indexterm>
  <indexterm><primary>registration</primary></indexterm>
  <indexterm><primary>completion</primary></indexterm>
  <indexterm><primary>WS-Business Activity</primary><secondary>WS-BA</secondary></indexterm>
  <indexterm><primary>coordination context</primary></indexterm>
  <indexterm><primary>Activation Coordinator</primary></indexterm>
  <indexterm><primary>Volatile2PC</primary></indexterm>
  <indexterm><primary>Durable2PC</primary></indexterm>
  <indexterm><primary>Two-Phase Commit</primary><secondary>2PC</secondary></indexterm>
  <indexterm><primary>One-Phase Commit</primary><secondary>1PC</secondary></indexterm>
  <indexterm><primary>BusinessAgreementWithParticipantCompletion</primary></indexterm>
  <indexterm><primary>BusinessAgreementWithCoordinatorCompletion</primary></indexterm>
  
  <para>
    This section discusses fundamental concepts associated with the WS-Coordination, WS-Atomic Transaction and WS-Business Activity protocols, as defined in each protocol's specification. Foundational information about these protocols is important to understanding the remaining material covered in this guide.
  </para>
  <!-- I don't like this but it's in the original so I'll leave it for now. -->
  <note>
    <para>
      If you are familiar with the WS-Coordination, WS-Atomic Transaction, and WS-Business Activity specifications you may only need to skim this chapter.
    </para>
  </note>
  
  <section>
    <title>WS-Coordination</title>
    <para>
      In general terms, <firstterm>coordination</firstterm> is the act of one entity,known as the coordinator, disseminating information to a number of participants for some domain-specific reason. This reason could be to reach consensus on a decision by a distributed transaction protocol, or to guarantee that all participants obtain a specific message, such as in a reliable multicast environment. When parties are being coordinated, information, known as the <firstterm>coordination context</firstterm>, is propagated to tie together operations which are logically part of the same coordinated work or activity. This context information may flow with normal application messages, or may be an explicit part of a message exchange. It is specific to the type of coordination being performed.
    </para>
    <para>
      The fundamental idea underpinning <firstterm>WS-Coordination (WS-C)</firstterm> is that a coordination infrastructure is needed in a Web Services environment. The WS-C specification defines a framework that allows different coordination protocols to be plugged in to coordinate work between clients, services, and participants, as shown in <xref linkend="fig-ws-c-architecture" />.
    </para>

    <figure id="fig-ws-c-architecture">
      <title>WS-C Architecture</title>
      <mediaobject>
	<imageobject>
	  <imagedata fileref="images/fig-ws-c-overview.png" format="PNG"/>
	</imageobject>
	<textobject>
	  <para>
	    The WS-C specification speaks of <firstterm>activities</firstterm>, which are distributed units of work, involving one or more parties. These parties may be services, components, or even objects. At this level, an activity is minimally specified and is simply created, run, and then completed.
	  </para>
	</textobject>
      </mediaobject>
    </figure>

    <para>
      Whatever coordination protocol is used, and in whatever domain it is deployed, the same generic requirements are present.
    </para>
    <itemizedlist id="list-requirements-for-wsc">
      <title>Generic Requirements for WS-C</title>
      <listitem><para>Instantiation, or activation, of a new coordinator for the specific coordination protocol, for a particular application instance.</para></listitem>
      <listitem><para>Registration of participants with the coordinator, such that they will receive that coordinator’s protocol messages during (some part of) the application’s lifetime.</para></listitem>
      <listitem><para>Propagation of contextual information between Web Services that comprise the application.</para></listitem>
      <listitem><para>An entity to drive the coordination protocol through to completion.</para></listitem>
    </itemizedlist>
    
    <para>
      The first three of the points in <xref linkend="list-requirements-for-wsc" /> are the direct responsibility of WS-C, while the fourth is the responsibility of a third-party entity. The third-party entity is usually the client component of the overall application. These four WS-C roles and their relationships are shown in <xref linkend="fig-wsc-four-roles" />.
    </para>
    
    <figure id="fig-wsc-four-roles">
      <title>Four Roles in WS-C</title>
      <mediaobject>
	<imageobject>
	  <imagedata fileref="images/fig-wsc-four-roles.png" format="PNG"/>
	</imageobject>
      </mediaobject>
    </figure>

    <section>
      <title>Activation</title>

      <!--
      <para>
	The WS-C framework exposes an Activation Service which supports the creation of coordinators for specific coordination protocols and retrieval of associated contexts. Activation services are invoked asynchronously, and so the specification defines the interfaces of the activation service itself and of the invoking service. This allows the activation service to call back to deliver the results of the activation, which consist of a context that identifies the protocol type and coordinator location. These interfaces are presented in <xref linkend="example-wsc-interfaces" />. The code shows that the activation service has a one-way operation that expects to receive a <systemitem>CreateCoordinationContext</systemitem> message. The service that sends the <systemitem>CreateCoordinationContext</systemitem> message expects to be called back with a <systemitem>CreateCoordinationContextResponse message</systemitem>, or to be notified of a problem via an error message.
      </para>
      -->
      <para>
	The WS-C framework exposes an Activation Service which supports the
	creation of coordinators for specific coordination protocols and
	retrieval of associated contexts. Activation services are invoked
	synchronously using an RPC style exchange. So, the service WSDL defines
	a single port declaring a
	<methodname>CreateCoordinationContext</methodname> operation.  This
	operation takes an input specfying the details of the transaction to be
	created, including the type of coordination required, timeout, and other
	relevant information. It returns an output containing the details of the
	newly-created transaction context: the transaction identifier,
	coordination type, and registration service URL.
      </para>
      
      <example id="example-wsc-interfaces">
	<title></title>
	<programlisting role="XML" language="XML"><xi:include href="extras/example-wsc-interfaces.xml" xmlns:xi="http://www.w3.org/2001/XInclude" parse="text" /></programlisting>
      </example>

      <note>
	<!--
	<para>
	  The Activation Coordinator service employs an RPC-style message exchange, so an Activation Requester service is not necessary.
	</para>
	-->
	<para>
	  The 1.0 Activation Coordinator service employs an asynchronous message 
	  exchange comprised of two one-way messages, so an Activation Requester 
	  service is also necessary.
	</para>
      </note>
    </section> <!--       <title>Activation</title> -->

    <section>
      <title>Registration</title>
      <!--
      <para>
	The context returned by the activation service includes information which exposes a Registration Service. This service allows participants to register to receive protocol messages from the coordinator which is associated with the context. Depending upon the coordination protocol, more than one choice of participant protocol may be available. Like the activation service, the registration service assumes asynchronous communication. Thus, it specifies WSDL for both registration service and registration requester. See <xref linkend="example-wsc-registration" /> for more information.
      </para>
      -->
      <para>
	The context returned by the activation service includes the URL of a 
	Registration Service. When a web service receieves a service request 
	accompanied by a transaction context, it contacts the Registration 
	Service to enroll as a participant in the transaction. The registration 
	request includes a participant protocol defining the role the web 
	service wishes to take in the transaction. Depending upon the 
	coordination protocol, more than one choice of participant protocol 
	may be available. 
      </para>
      <para>
	Like the activation service, the registration service assumes
	synchronous communication. Thus, the service WSDL exposes a single port
	declaring a <methodname>Register</methodname> operation. This operation
	takes an input specifying the details of the participant which is to be
	registered, including the participant protocol type. It returns a
	corresponding output response.
      </para>
      <example id="example-wsc-registration">
	<title>Registration ServiceWSDL Interface</title>
	<programlisting><xi:include href="extras/example-wsc-registration.xml" xmlns:xi="http://www.w3.org/2001/XInclude" parse="text" /></programlisting>
      </example>

      <para>
	Once a participant is registered with a coordinator through the registration service, it receives coordination messages from the coordinator. Typical messages include such things as “prepare to complete” and “complete” messages, if a two-phase protocol is used. Where the coordinator’s protocol supports it, participants can also send messages back to the coordinator.
      </para>

      <note>
	<!--
	<para>
	  The Registration Coordinator employs an RPC-style message exchange, so a Registration Requester service is not necessary.
	</para>
	-->
	<para>
	  The 1.0 Registration Coordinator service employs an asynchronous 
	  message exchange comprised of two one way messages, so a Registration 
	  Requester service is also necessary
	</para>
      </note>
    </section> <!--       <title>Registration</title> -->

    <section>
      <title>Completion</title>
      <para>
	The role of terminator is generally filled by the client application. At an appropriate point, the client asks the coordinator to perform its particular coordination function with any registered participants, to drive the protocol through to its completion. After completion, the client application may be informed of an outcome for the activity. This outcome may take any form along the spectrum from simple success or failure notification, to complex structured data detailing the activity’s status.
      </para>
    </section> <!--     <title>Completion</title> -->
  </section> <!--     <title>WS-Coordination</title> -->

  <section>
    <title>WS-Transaction</title>
    <para>
      <firstterm>WS-Transaction (WS-T)</firstterm> comprises the pair of
      transaction coordination protocols, <firstterm>WS-Atomic Transaction
      (WS-AT)</firstterm> and <firstterm>WS-Business Activity
      (WS-BA)</firstterm>, which utilize the coordination framework provided by
      <firstterm>WS-Coordination (WS-C)</firstterm>.
    </para>
    <para>
      <firstterm>WS-Transactions</firstterm> was developed to unify existing traditional transaction processing systems, allowing them to communicate reliably with one another without changes to the systems' own function.
    </para>

    <section>
      <title>WS-Transaction Foundations</title>
      <para>
	WS-Transaction is layered upon the WS-Coordination protocol, as shown in as
	shown in <xref linkend="wsc-wst-interop" />.
      </para>

      <figure id="wsc-wst-interop">
	<title>WS-Coordination, WS-Transaction, and WS-Business Activity</title>
	<mediaobject>
	  <imageobject>
	    <imagedata fileref="images/fig-wsc-wst-interop.png" format="PNG"/>
	  </imageobject>
	  <textobject>
	    <para></para>
	  </textobject>
	</mediaobject>
      </figure>

      <para>
	WS-C provides a generic framework for specific coordination protocols, like WS-Transaction, used in a modular fashion. WS-C provides only context management, allowing contexts to be created and activities to be registered with those contexts. WS-Transaction leverages the context management framework provided by WS-C in two ways.
      </para>
      <orderedlist>
	<listitem>
	  <para>
	    It extends the WS-C context to create a transaction context.
	  </para>
	</listitem>
	<listitem>
	  <para>
	    It augments the activation and registration services with a number of additional services (Completion, Volatile2PC, Durable2PC, BusinessAgreementWithParticipantCompletion, and BusinessAgreementWithCoordinatorCompletion) and two protocol message sets (one for each of the transaction models supported in WS-Transaction), to build a fully-fledged transaction coordinator on top of the WS-C protocol infrastructure.
	  </para>
	</listitem>
	<listitem>
	  <para>
	    An important aspect of WS-Transaction that differs from traditional 
	    transaction protocols is that a synchronous request/response model is 
	    not assumed. Sequences of one way messages are used to implement 
	    communications between the client/participant and the coordination 
	    services appropriate to the transaction's coordination and participant 
	    protocols. This is significant because it means that the client and 
	    participant containers must deploy XTS service endpoints to receive 
	    messages from the coordinator service.
	  </para>
	  <para>
	    This requirement is visible in the details of the
	    <methodname>Register</methodname> and
	    <methodname>RegisterResponse</methodname> messages declared in the
	    Registration Service WSDL in <xref
	    linkend="example-wsc-registration" />. The
	    <methodname>Register</methodname> message contains the URL of an
	    endpoint in the client or web service container. This URL is used
	    when a WS-Transaction coordination service wishes to dispatch a
	    message to the clinet or web service. Similarly, the
	    <methodname>RegisterResponse</methodname> message contains a URL
	    iendtifying an endpoint for the protocol-specific WS-Transaction
	    coordination service for which the client/web service is registered,
	    allowing messages to be addressed to the transaction coordinator.
	  </para>
	</listitem>
      </orderedlist>
    </section> <!--       <title>WS-Coordination Foundations</title> -->

    <section>
      <title>WS-Transaction Architecture</title>
      <!--
      <para>
	WS-Transaction views the service and participant as distinct roles, making the distinction between a transaction-aware service and the participants that act on behalf of the service during a transaction. Transactional services deal with business-level protocols, while the participants handle the underlying WS-Transaction protocols, as shown <xref linkend="ws-trans-global-view" />.
      </para>
      -->

      <para>
	WS-Transaction distnguishes the transaction-aware web service in its
	role executing business-logic, from the web service acting as a
	participant in the transaction, communicating with and responding to its
	transaction coordinator. Transaction-aware web services deal with
	application clients using business-level protocols, while the
	participant handles the underlying WS-Transaction protocols, as shown in
	<xref linkend="ws-trans-global-view" />.
      </para>
      
      <figure id="ws-trans-global-view">
	<title>WS-Transaction Global View</title>
	<mediaobject>
	  <imageobject>
	    <imagedata fileref="images/ws-trans-global-view.png" format="PNG"/>
	  </imageobject>
	</mediaobject>
      </figure>

      <para>
	A transaction-aware web service encapsulates the business logic or work that needs to be conducted within the scope of a transaction. This work cannot be confirmed by the application unless the transaction also commits. Thus, control is ultimately removed from the application and given to the transaction.
      </para>
      <para>
	The participant is the entity that, under the dictates of the transaction coordinator, controls the outcome of the work performed by the transaction-aware Web service. In <xref linkend="ws-trans-global-view" />, each web service is shown with one associated participant that manages the transaction protocol messages on behalf of its web service. <xref linkend="ws-trans-services-participants" />, however, shows a close-up view of a single web service, and a client application with their associated participants.
      </para>
      <figure id="ws-trans-services-participants">
	<title>WS-Transaction Web Services and Participants</title>
	<mediaobject>
	  <imageobject>
	    <imagedata fileref="images/fig-ws-trans-services-participants.png" format="PNG"/>
	  </imageobject>
	</mediaobject>
      </figure>
      <!--
      <para>
	The transaction-aware Web service and its participant both serve a shared transactional resource, and the JAXTX API provides a control relationship between them. In <xref linkend="ws-trans-services-participants" />, the database is assumed to be accessed through a transactional JDBC database driver, where SQL statements are sent to the database for processing via that driver, but where those statements are tentative and only commit if the transaction does. For this to work, the driver/database associates a participant with the transaction. This participant informs the database of the transaction outcome. Since all transactional invocations on the Web service carry a transaction context, the participant working with the database is able to identify the work that the transactional service has done within the scope of a specific transaction, and either commit or roll back the work.
      </para>
      -->
      <para>
	The transaction-aware web service employs a back end database accessed
	via a JDBC driver, which sends SQL statements to the database for
	processing. However, those statements should only commit if the
	enclosing web service transaction does. For this to work, the web
	service must employ transaction bridging. Transaction bridging registers
	a participant with the coordinator for the web service transaction and
	creates a matching XA transaction within which it can invoke the driver
	to make tentative changes to the database. The web service ensures that
	service requests associated with a specific web service transaction are
	executed in the scope of the corresponding XA transaction, grouping
	changes common to a given transaction while isolating changes belonging
	to different transactions. The participant responds to prepare, commit,
	or rollback requests associated from the web service transaction
	coordinator by forwarding the same operations to the underlying XA
	transaction coordinator, ensuring that the local outcome in the database
	corresponds with the global outcome of the web service transaction as a
	whole.
      </para>
      <para>
	Things are less complex for the client. Through its API, the client application registers a participant with the transaction, and uses this participant to control termination of the transaction.
      </para>
    </section> <!--       <title>WS-Transaction Architecture</title> -->

    <section>
      <title>WS_Transaction Models</title>
      <para>
	It has been established that traditional transaction models are not appropriate for Web Services. No one specific protocol is likely to be sufficient, given the wide range of situations where Web service transactions are likely to be used. The WS-Transaction specification proposes two distinct models, where each supports the semantics of a particular kind of B2B interaction. 
      </para>

      <para>
	The following discussion presents the interactions between the client, web service and the transaction coordinator in great detail for expository purposes only. Most of this activity happens automatically behind the scenes. The actual APIs used to initiate and complete a transaction and to register a participant and drive it through the commit or abort process are described in <xref linkend="sec-xts-api" />.
      </para>

      
      <section>
	<title>Atomic Transactions</title>
	<para>
	  An <firstterm>atomic transaction (AT)</firstterm> is similar to
	  traditional ACID transactions, and is designed to support
	  short-duration interactions where ACID semantics are
	  appropriate. <!--Within the scope of an AT, services typically enroll
	  transaction-aware resources, such as databases and message queues,
	  indirectly as participants under the control of the transaction. When
	  the transaction terminates, the outcome decision of the AT is
	  propagated to each enlisted resource via the participant, and the
	  appropriate <systemitem>commit</systemitem> or
	  <systemitem>rollback</systemitem> actions are taken by each.-->Within
	  the scope of an AT, web services typically employ bridging to allow
	  them to access XA resources, such as databases and message queues,
	  under the control of the web service transaction. When the transaction
	  terminates, the participant propagates the outcome decision of the AT
	  to the XA resources, and the appropriate commit or rollback actions
	  are taken by each.
	</para>
	<para>
	  All services and associated participants are expected to provide ACID semantics, and it is expected that any use of atomic transactions occurs in environments and situations where ACID is appropriate. Usually, this environment is a trusted domain, over short durations.
	</para>
	<procedure>
	  <title>Atomic Transaction Process</title>
	  <step>
	    <para>
	      To begin an atomic transaction, the client application first locates a WS-C Activation Coordinator web service that supports WS-Transaction.
	    </para>
	  </step>
	  <step>
	    <para>
	      The client sends a WS-C <systemitem>CreateCoordinationContext</systemitem> message to the service, specifying <ulink url="http://schemas.xmlsoap.org/ws/2004/10/wsat" /> as its coordination type.
	    </para>
	  </step>
	  <step>
	    <para>
	      The client receives an appropriate WS-Transaction context from the activation service.
	    </para>
	  </step>
	  <step>
	    <para>
	      The response to the <systemitem>CreateCoordinationContext</systemitem> message, the transaction context, has its <systemitem>CoordinationType</systemitem> element set to the WS-Atomic Transaction namespace, <ulink url="http://schemas.xmlsoap.org/ws/2004/10/wsat" />. It also contains a reference to the atomic transaction coordinator endpoint, the WS-C Registration Service, where participants can be enlisted.
	    </para>
	  </step>
	  <step>
	    <para>
	      The client normally proceeds to invoke Web Services and complete the transaction, either committing all the changes made by the web services, or rolling them back. In order to be able to drive this completion activity, the client must register itself as a participant for the <systemitem>Completion</systemitem> protocol, by sending a <systemitem>Register</systemitem> message to the Registration Service whose endpoint was returned in the Coordination Context.
	    </para>
	  </step>
	  <step>
	    <para>
	      Once registered for Completion, the client application then interacts with Web Services to accomplish its business-level work. With each invocation of a business Web service, the client inserts the transaction context into a SOAP header block, such that each invocation is implicitly scoped by the transaction. The toolkits that support WS-Atomic Transaction-aware Web Services provide facilities to correlate contexts found in SOAP header blocks with back-end operations. This ensures that modifications made by the Web service are done within the scope of the same transaction as the client and subject to commit or rollback by the transaction coordinator.
	    </para>
	  </step>
	  <step>
	    <para>
	      Once all the necessary application-level work is complete, the client can terminate the transaction, with the intent of making any changes to the service state permanent. The completion participant instructs the coordinator to try to commit or roll back the transaction. When the commit or roll-back operation completes, a status is returned to the participant to indicate the outcome of the transaction.
	    </para>
	  </step>
	</procedure>

	<para>
	  Although this description of the completion protocol seems straightforward, it hides the fact that in order to resolve the transaction to an outcome, several other participant protocols need to be followed.
	</para>

	<variablelist>
	  <varlistentry>
	    <term>Volatile2pc</term>
	    <listitem>
	      <para>
		The first of these protocols is the optional <firstterm>Volatile2PC</firstterm> (2PC is an abbreviation referring to the two-phase commit). The Volatile2PC protocol is the WS-Atomic Transaction equivalent of the synchronization protocol discussed earlier. It is typically executed where a Web service needs to flush volatile (cached) state, which may be used to improve performance of an application, to a database prior to the transaction committing. Once flushed, the data is controlled by a two-phase aware participant.
	      </para>
	      <para>
		When the completion participant initiates a <systemitem>commit</systemitem> operation, all Volatile2PC participants are informed that the transaction is about to complete, via the <systemitem>prepare</systemitem> message. The participants can respond with one of three messages: <systemitem>prepared</systemitem>, <systemitem>aborted</systemitem>, or <systemitem>readonly</systemitem>. A failure at this stage causes the transaction to roll back.
	      </para>
	    </listitem>
	  </varlistentry>
	  <varlistentry>
	    <term>Durable2PC</term>
	    <listitem>
	      <para>
		The next protocol in the WS-Atomic Transaction is <firstterm>Durable2PC</firstterm>. The Durable2PC protocol is at the core of WS-Atomic Transaction. It brings about the necessary consensus between participants in a transaction, so the transaction can safely be terminated.
	      </para>
	      <para>
		The Durable2PC protocol ensures atomicity between participants, and is based on the classic technique of <phrase>two-phase commit with presumed abort</phrase>.
	      </para>
	      <procedure>
		<title>Durable2PC Procedure</title>
		<step>
		  <para>
		    During the first phase, when the coordinator sends the prepare message, a participant must make durable any state changes that occurred during the scope of the transaction, so these changes can either be rolled back or committed later. None of the original state information can be lost at this point, since the atomic transaction may still roll back. If the participant cannot <systemitem>prepare</systemitem>, it must inform the coordinator, by means of the <systemitem>aborted</systemitem> message. The transaction will ultimately roll back. If the participant is responsible for a service that did not change any of the transaction's data,, it can return the <systemitem>readonly</systemitem> message, causing it to be omitted from the second phase of the commit protocol. Otherwise, the <systemitem>prepared</systemitem> message is sent by the participant.
		  </para>
		</step>
		<step>
		  <para>
		    If no failures occur during the first phase, Durable2PC proceeds to the second phase, in which the coordinator sends the <systemitem>commit</systemitem> message to participants. Participants then make permanent the tentative work done by their associated services, and send a <systemitem>committed</systemitem> message to the coordinator. If any failures occur, the coordinator sends the <systemitem>rollback</systemitem> message to all participants, causing them to discard tentative work done by their associated services, and delete any state information saved to persistent storage at <systemitem>prepare</systemitem>, if they have reached that stage. Participants respond to a rollback by sending an <systemitem>aborted</systemitem> message to the coordinator.
		  </para>
		</step>
	      </procedure>
	      <note>
		<para>
		  The semantics of the WS-Atomic Transaction protocol do not include the one-phase commit optimization. A full two-phase commit is always used, even where only a single participant is enlisted.
		</para>
	      </note>
	    </listitem>
	  </varlistentry>
	</variablelist>
	<para>
	  <xref linkend="two-pc-participant-state-transitions" /> shows the state transitions of a WS-Atomic Transaction and the message exchanges between coordinator and participant. Messages generated by the coordinator are represented by solid lines, while the participants' messages use dashed lines.
	</para>
	<figure id="two-pc-participant-state-transitions">
	  <title>WS-Atomic Two-Phase Participant State Transitions</title>
	  <mediaobject>
	    <imageobject>
	      <imagedata fileref="images/fig-2pc-participant-state-transitions.png" format="PNG"/>
	    </imageobject>
	  </mediaobject>
	</figure>

	<para>
	  Once the Durable2PC protocol completes, the <systemitem>Completion</systemitem> protocol that originally began the termination of the transaction can complete, and inform the client application whether the transaction was committed or rolled back. Additionally, the Volatile2PC protocol may complete.
	</para>
	<para>
	  Like the <systemitem>prepare</systemitem> phase of Volatile2PC, the final phase is optional and can be used to inform participants about the transaction's completion, so that they can release resources such as database connections.
	</para>
	<para>
	  Any registered Volatile2PC participants are invoked after the transaction terminates, and are informed about the transaction's completion state by the coordinator. Since the transaction has terminated, any failures of participants at this stage are ignored, since they have no impact on outcomes.
	</para>
	<para>
	  <xref linkend="fig-at-model" /> illustrates the intricate interweaving of individual protocols comprising the AT as a whole.
	</para>
	<figure id="fig-at-model">
	  <title></title>
	  <mediaobject>
	    <imageobject>
	      <imagedata fileref="images/fig-at-model.png" format="PNG"/>
	    </imageobject>
	  </mediaobject>
	</figure>
      </section> <!-- <title>Atomic Transactions </title> -->

      
      <section>
	<title>Business Activities</title>
	<para>
	  Most B2B applications require transactional support in order to guarantee consistent outcome and correct execution. These applications often involve long-running computations, loosely coupled systems, and components that do not share data, location, or administration. It is difficult to incorporate atomic transactions within such architectures.
	</para>
	<para>
	  For example, an online bookshop may reserve books for an individual for a specific period of time. However, if the individual does not purchase the books within that period, they become available again for purchase by other customers. Because it is not possible to have an infinite supply of stock, some online shops may seem, from the user's perspective, to reserve items for them, while actually allow others to preempt the reservation. A user may discover, to his disappointment, that the item is no longer available.
	</para>
	<para>
	  A <firstterm>Business Activity (BA)</firstterm> is designed specifically for these kinds of long-duration interactions, where it is impossible or impractical to exclusively lock resources.
	</para>
	<procedure>
	  <title>BA Process Overview</title>
	  <step>
	    <para>
	      Services are requested to do work.
	    </para>
	  </step>
	  <step>
	    <para>
	      Where those services have the ability to undo any work, they inform the BA, in case the BA later decides the cancel the work. If the BA suffers a failure. it can instruct the service to execute its <systemitem>undo</systemitem> behavior.
	    </para>
	  </step>
	</procedure>
	<para>
	  The key to BA is that how services do their work and provide compensation mechanisms is not the responsibility of the WS-BA specification. It is delegated to the service provider.
	</para>
	<para>
	  The WS-BA defines a protocol for Web Services-based applications to enable existing business processing and work-flow systems to wrap their proprietary mechanisms and interoperate across implementations and business boundaries.
	</para>
	<para>
	  Unlike the WS-AT protocol model, where participants inform the coordinator of their state only when asked, a child activity within a BA can specify its outcome to the coordinator directly, without waiting for a request. A participant may choose to exit the activity or may notify the coordinator of a failure at any point. This feature is useful when tasks fail, since the notification can be used to modify the goals and drive processing forward, without the need to wait until the end of the transaction to identify failures. A well-designed Business Activity should be proactive.
	</para>
	<para>
	  The BA protocols employ a compensation-based transaction model. When a participant in a business activity completes its work, it may choose to exit the activity. This choice does not allow any subsequent rollback. Alternatively, the participant can complete its activity, signaling to the coordinator that the work it has done can be compensated if, at some later point, another participant notifies a failure to the coordinator. In this latter case, the coordinator asks each non-exited participant to compensate for the failure, giving them the opportunity to execute whatever compensating action they consider appropriate. For instance, participant might credit a bank account which it previously debited. If all participants exit or complete without failure, the coordinator notifies each completed participant that the activity has been closed. 	  
	</para>
	<para>
	  Underpinning all of this are three fundamental assumptions, detailed in <xref linkend="wsba-assumptions" />.
	</para>
	<itemizedlist id="wsba-assumptions">
	  <title>Assumptions of WS-BA</title>
	  <listitem>
	    <para>
	      All state transitions are reliably recorded, including application state and coordination metadata (the record of sent and received messages).
	    </para>
	  </listitem>
	  <listitem>
	    <para>
	      All request messages are acknowledged, so that problems are detected as early as possible. This avoids executing unnecessary tasks and can also detect a problem earlier when rectifying it is simpler and less expensive.
	    </para>
	  </listitem>
	  <listitem>
	    <para>
	      As with atomic transactions, a <firstterm>response</firstterm> is defined as a separate operation, not as the output of the request. Message I/O implementations typically have timeout requirements too short for BA responses. If the response is not received after a timeout, it is re-sent, repeatedly, until a response is received. The receiver discards all but one identical request received.
	    </para>
	  </listitem>
	</itemizedlist>

	<para>
	  The BA model has two participant protocols: <systemitem>BusinessAgreementWithParticipantCompletion</systemitem> and <systemitem>BusinessAgreementWithCoordinatorCompletion</systemitem>. Unlike the AT protocols which are driven from the coordinator down to participants, this protocol takes the opposite approach.
	</para>

	<variablelist>
	  <varlistentry>
	    <term>BusinessAgreementWithParticipantCompletion</term>
	    <listitem>
	      <procedure>
		<step>
		  <para>
		    A participant is initially created in the Active state.
		  </para>
		</step>
		<step>
		  <para>
		    If it finishes its work and it is no longer needed within the scope of the BA (such as when the activity operates on immutable data), the participant can unilaterally decide to exit, sending an <systemitem>exited</systemitem> message to the coordinator. However, if the participant finishes and wishes to continue in the BA, it must be able to compensate for the work it has performed. In this case, it sends a <systemitem>completed</systemitem> message to the coordinator and waits for the coordinator to notify it about the final outcome of the BA. This outcome is either a <systemitem>close</systemitem> message, meaning the BA has completed successfully, or a <systemitem>compensate</systemitem> message indicating that the participant needs to reverse its work.
		  </para>
		</step>
	      </procedure>
	    </listitem>
	  </varlistentry>
	  <varlistentry>
	    <term>BusinessAgreementWithCoordinatorCompletion</term>
	    <listitem>
	      <para>
		The <systemitem>BusinessAgreementWithCoordinatorCompletion</systemitem> differs from the <systemitem>BusinessAgreementWithParticipantCompletion</systemitem> protocol in that the participant cannot autonomously decide to complete its participation in the BA, even if it can be compensated.
	      </para>
	      <procedure>
		<step>
		  <para>
		    Instead, the completion stage is driven by the client which created the BA, which sends a <systemitem>completed</systemitem> message to the coordinator.
		  </para>
		</step>
		<step>
		  <para>
		    The coordinator sends a <systemitem>complete</systemitem> message to each participant, indicating that no further requests will be sent to the service associated with the participant.
		  </para>
		</step>
		<step>
		  <para>
		    The participant continues on in the same manner as in the BusinessAgreementWithParticipantCompletion protocol.
		  </para>
		</step>
	      </procedure>
	    </listitem>
	  </varlistentry>
	</variablelist>
	<para>
	  The advantage of the BA model, compared to the AT model, is that is allows the participation of services that cannot lock resources for extended periods.
	</para>
	<para>
	  While the full ACID semantics are not maintained by a BA, consistency can still be maintained through compensation. The task of writing correct compensating actions to preserve overall system consistency is the responsibility of the developers of the individual services under control of the BA. Such compensations may use backward error recovery, but forward recovery is more common.
	</para>
	<para>
	  <xref linkend="fig-bawpc-state-transitions" /> shows the state transitions of a WS-BA <systemitem>BusinessAgreementWithParticipantCompletion</systemitem> participant and the message exchanges between coordinator and participant. Messages generated by the coordinator are shown with solid lines, while the participants' messages are illustrated with dashed lines.
	</para>
	<figure id="fig-bawpc-state-transitions">
	  <title></title>
	  <mediaobject>
	    <imageobject>
	      <imagedata fileref="images/fig-bawpc-state-transitions.png" format="PNG"/>
	    </imageobject>
	  </mediaobject>
	</figure>
	
	<para>
	  <xref linkend="fig-bawcc-state-transitions" /> shows the state transitions of a WS-BA <systemitem>BusinessAgreementWithCoordinatorCompletion</systemitem> participant and the message exchanges between coordinator and participant. Messages generated by the coordinator are shown with solid lines, while the participants' messages are illustrated with dashed lines.
	</para>
	<figure id="fig-bawcc-state-transitions">
	  <title></title>
	  <mediaobject>
	    <imageobject>
	      <imagedata fileref="images/fig-bawcc-state-transitions.png" format="PNG"/>
	    </imageobject>
	  </mediaobject>
	</figure>
      </section> <!-- 	<title>Business Activities</title> -->
    </section> <!-- <title>WS-Transaction Models</title> -->
    
    <section>
      <title>Application Messages</title>
      <para>
	<firstterm>Application messages</firstterm> are the requests and responses sent between parties, that constitute the work of a business process. Any such messages are considered opaque by XTS, and there is no mandatory message format, protocol binding, or encoding style. This means that you are free to use any appropriate Web Services protocol. In XTS, the transaction context is propagated within the headers of SOAP messages.
      </para>

      <para>
	  XTS ships with support for service developers building WS-Transactions-aware services on the &APPSERVER;. Interceptors are provided for automatic context handling at both client and service, which significantly simplifies development, allowing you to concentrate on writing the business logic without being sidetracked by the transactional infrastructure. The interceptors add and remove context elements to application messages, without altering the semantics of the messages themselves. Any service which understands what to do with a WS-C context can use it. Services which are not aware of WS-C, WS-Atomic Transaction and WS-Business Activity can ignore the context. XTS manages contexts without user intervention.
      </para>

      <section>
	<title>WS-C, WS-Atomic Transaction, and WS-Business Activity Messages</title>
	<para>
	  Although the application or service developer is rarely interested in the messages exchanged by the transactional infrastructure, it is useful to understand what kinds of exchanges occur so that the underlying model can be fitted in to an overall architecture.
	</para>
	<para>
	  WS-Coordination, WS-Atomic Transaction and WS-Business Activity-specific messages are transported using SOAP messaging over HTTP. The types of messages that are propagated include instructions to perform standard transaction operations like <systemitem>begin</systemitem> and <systemitem>prepare</systemitem>. 
	</para>
	<note>
	  <para>
	    XTS messages do not interfere with messages from the application, an application need not use the same transport as the transaction-specific messages. For example, a client application might deliver its application-specific messages using SOAP RPC over SMTP, even though the XTS messages are delivered using a different mechanism.
	  </para>
	</note>
      </section> <!-- 	<title>WS-C, WS-Atomic Transaction, and WS-Business Activity Messages</title> -->
    </section> <!--       <title>Application Messages</title> -->
    
  </section>

  <section>
    <title>Summary</title>
    <para>
      XTS provides a coordination infrastructure which allows transactions to run between services owned by different business, across the Internet. That infrastructure is based on the WS-C, WS-Atomic Transaction and WS-Business Activity specifications. It supports two kinds of transactions: atomic transactions and business activities, which can be combined in arbitrary ways to map elegantly onto the transactional requirements of the underlying problem. The use of the whole infrastructure is simple, because its functionality is exposed through a simple transactioning API. XTS provides everything necessary to keep application and transactional aspects of an application separate, and to ensure that a system's use of transactions does not interfere with the functional aspects of the system itself.
    </para>
  </section> <!-- summary -->
</chapter>

