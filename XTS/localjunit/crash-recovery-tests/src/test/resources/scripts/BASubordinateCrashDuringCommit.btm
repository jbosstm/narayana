##############################################################################
# JBoss, Home of Professional Open Source
# Copyright 2009, Red Hat Middleware LLC, and individual contributors
# by the @authors tag. See the copyright.txt in the distribution for a
# full listing of individual contributors.
#
# This is free software; you can redistribute it and/or modify it
# under the terms of the GNU Lesser General Public License as
# published by the Free Software Foundation; either version 2.1 of
# the License, or (at your option) any later version.
#
# This software is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this software; if not, write to the Free
# Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
# 02110-1301 USA, or see the FSF site: http://www.fsf.org.
#
# @authors Andrew Dinn
#
# BA Subordinate Transaction Crash During Commit
#
# This script automates testing of a specific recovery scenario for the
# JBossTS XTS implementation of the WS-BA 1.1 protocol using orchestration
# rules. The basic scenario employs a coordinator, a subordinate coordinator
# and 2 web services running in a single JVM, the second one employing local
# (subordinate) coordination. It checks that the transaction rolls forward
# after crashing the coordinator when it tries to initiate a close. The
# scenario is as follows
# (** indicates intercession by a Byteman rule):
#
# AS boots
# Cient starts a WS-BA transaction T1
# Client invokes web service S1 with enlistPC/CC request
# S1 registers PC/CC participant P1 in T1
# Client invokes subordinate web service S2 with enlistPC/CC request
# S2 creates a subordinate BA transaction T2
# S2 registers CC pseudo-participant PP in T1
# S2 registers PC/CC participant P2 in T2
# Client invokes subordinate web service S2 with enlistPC/CC  request
# S2 resumes T2
# S2 registers PC/CC participant P3 in T2
#
# (PC Participants only)
# Client invokes web service S1 with complete request for P1
# P1 sends completed
# ** Rule system logs receipt of completed from P1
# Client invokes subordinate web service S2 with complete request for P2
# P2 sends completed
# ** Rule system logs receipt of completed from P2
# Client invokes subordinate web service S1 with complete request for P3
# P3 sends completed
# ** Rule system logs receipt of completed from P2
# (end of PC Participants only)
#
# Client initiates transaction close for T1
#
# (CC Participants only)
# Coordinator initiates complete of participant P1
# ** Rule system logs dispatch of complete to P1
# ** Rule system logs receipt of completed from P1
# (end of CC Participants only)
#
# Coordinator initiates complete of subordinate participant PP
# ** Rule system logs dispatch of complete to PP
# PP calls subordinate coordinator complete
# ** Rule system logs call to complete
#
# (CC Participants only)
# Subordinate coordinator initiates complete of participant P2
# ** Rule system logs dispatch of complete to P1
# ** Rule system logs receipt of completed from P1
# Subordinate coordinator initiates complete of participant P3
# ** Rule system logs dispatch of complete to P1
# ** Rule system logs receipt of completed from P1
# (end of CC Participants only)
#
# Subordinate coordinator calls prepare for T2
# ** Rule system logs prepare
# Subordinate coordinator complete returns
# ** Rule system logs return from complete
# PP sends completed to coordinator
# ** Rule system logs receipt of completed from PP
#
# Client closes transaction
# Coordinator initiates close of participant P1
# ** Rule system intercepts close and crashes JVM
#
# AS reboots
# Recovery system starts after 2 minutes
# Recovery system recreates transaction T1
# ** Rule system traces create
# Recovery system recreates transaction T2
# ** Rule system traces create
# Recovery system recreates participant engine for P1
# ** Rule system traces create
# Recovery system recreates participant engine for PP1
# ** Rule system traces create
# Recovery system recreates participant engine for P2
# ** Rule system traces create
# Recovery system recreates participant engine for P3
# ** Rule system traces create
# Recovery system recreates coordinator engine for P1
# ** Rule system traces create
# Recovery system recreates coordinator engine for PP1
# ** Rule system traces create
# Recovery system recreates coordinator engine for P2
# ** Rule system traces create
# Recovery system recreates coordinator engine for P3
# ** Rule system traces create
# Recovery system calls replay of COMPLETED transaction
# ** Rule system traces COMPLETED replay invocation
#
# Coordinator sends close to P1
# ** Rule system traces dispatch of close
# P1 replies with closed
# ** Rule system traces dispatch of closed
#
# Coordinator sends close to PP
# ** Rule system traces dispatch of close
#
# (optional depending upon recovery timing)
# PP throws System Exception because subordinate coordinator is not avaiable
# ** Rule system traces call to close
# Coordinator resends close to PP
# ** Rule system traces dispatch of close
# (end optional section -- n.b. may be repeated)
#
# PP calls subordinate coordinator close
# ** Rule system traces call to close
#
# Subordinate coordinator sends close to P2
# ** Rule system traces dispatch of close
# P2 replies with closed
# ** Rule system traces receipt of closed
#
# Subordinate oordinator sends close to P3
# ** Rule system traces dispatch of close
# P3 replies with closed
# ** Rule system traces receipt of closed
#
# Subordinate coordinator deletes T2 from log
# ** Rule system traces delete of T2
#
# return from subordinate coordinator close
# ** Rule system traces return from close
#
# PP1 replies with closed
# ** Rule system traces receipt of closed
#
# Coordinator deletes T1 from log and completes close
# ** Rule system traces delete of T1
# ** Rule system detects 2nd completed close and kills JVM
#
# Use of this script
#
# The default way of exercising this test is to deploy the xtstest war
# to a single AS and configure it to run the relevant XTS Service Test.
# The web services and coordinator will be located with the client.
# The number of participants and subordinate participants can actually be
# 2, 3 or more. The  web service(s), client (i.e. the XTS Service Test which
# drives the test) and coordinator and subordinate coordinator service must
# be colocated for this scritp to work (it is possible to distribute all of
# these agents if desired but that woud lrequire more complex script rules).
# The AS should crash when the client closes. At reboot the rest of the test
# should run automatically and the server should be killed after the recovered
# transaction is successfuly replayed.
#
# This script needs to be passed to a Byteman agent in the JVM running
# the coordinator service both at first boot and at reboot. Output will be
# written to file testlog in the working directory of the AS.
#
# XTS Service tests which can operate with this scenario can be selected for
# execution at AS boot by the XTSServiceTestRunnerBean by setting system
# property
#    org.jboss.jbossts.xts.servicetests.XTSServiceTestName
# to the name of a class which will execute the test. This property must
# be defined in the JVM running the AS to which the xtstest war is deployed
# i.e. the client AS. n.b. if the client is colocated with the coordinator then
# this property must be left undefined at AS reboot otherwise the client
# will run again, starting a new TX which may interfere with recovery of the
# crashed TX. It is also possible to run the service test using the form
# interface provided on the xtstest war's main index page.
#
# Available tests include:
#
# org.jboss.jbossts.xts.servicetests.test.ba.subordinate.MultiParticipantCoordinatorCompletionParticipantCloseTest
# this test starts an activity then registers a CC participant with the service whose location is defined by
# system property:
#    org.jboss.jbossts.xts.servicetests.ServiceURL1
# if this is not set the value used defaults to
#    http://localhost:8080/xtstest/xtsservicetest1
# the test then registers two CC participants with a second web service (which must install a
# subordinate transaction) whose location is defined system property:
#    org.jboss.jbossts.xts.servicetests.serviceURL1
# if this is not set the value used defaults to
#    http://localhost:8080/xtstest/xtssubservicetest1
# The test then closes the transaction
#
# org.jboss.jbossts.xts.servicetests.test.ba.subordinate.MultiParticipantParticipantCompletionParticipantCloseTest
# this test starts an activity then registers a PC participant with the service whose location is defined by
# system property:
#    org.jboss.jbossts.xts.servicetests.ServiceURL1
# if this is not set the value used defaults to
#    http://localhost:8080/xtstest/xtsservicetest1
# the test then registers two PC participants with a second web service (which must install a
# subordinate transaction) whose location is defined system property:
#    org.jboss.jbossts.xts.servicetests.serviceURL1
# if this is not set the value used defaults to
#    http://localhost:8080/xtstest/xtssubservicetest1
# The test then sends complete requests for all three participants and
# closes the transaction
#
# Expected output
#
# After the first boot the JVM should exit leaving the following in file testlog
# (the number and order of entries depends upon how many and which type of participants
# are enlisted)
#
#   complete sent for CC participant XXXXXX ***
#   complete received for CC participant XXXXXX  ***
#   completed sent for CC/PC participant XXXXXX
#   completed received for CC/PC participant XXXXXX
#   complete sent for CC participant XXXXXX
#   complete received for CC participant XXXXXX
#   complete called for pseudo participant XXXXXX
#   complete sent for CC participant XXXXXX ***
#   complete received for CC participant XXXXXX ***
#   completed sent for CC participant XXXXXX
#   completed received for CC participant XXXXXX
#   prepare for transaction XXXXXX
#   saved to disk transaction XXXXXX
#   complete returned for pseudo participant XXXXXX
#   completed sent for CC participant XXXXXX
#   completed received for CC participant XXXXXX
#   saved to disk transaction XXXXXX
#   JVM exit
#
# n.b. *** indicates trace which may be omitted
#      there should be at least one completed sent/received message received for each CC/PC participant
#        trace for PC participant completed will precede the call to pseudo participant complete
#      there should also be at least one complete sent/received message received for each CC participant
#        plus an extra complete sent/received message for the pseduo-participant (it is always registered as CC)
#      there should be at least one complete called/complete returned message for the pseudo participant
#
# and in some cases there may be repeat messages
#
# After reboot the JVM should exit leaving output in the following format in file
# testlog.
#
#   complete sent for CC participant XXXXXX ***
#   complete received for CC participant XXXXXX  ***
#   completed sent for CC/PC participant XXXXXX
#   completed received for CC/PC participant XXXXXX
#   complete sent for CC participant XXXXXX
#   complete received for CC participant XXXXXX
#   complete called for pseudo participant XXXXXX
#   complete sent for CC participant XXXXXX ***
#   complete received for CC participant XXXXXX ***
#   completed sent for CC participant XXXXXX
#   completed received for CC participant XXXXXX
#   prepare for transaction XXXXXX
#   saved to disk transaction XXXXXX
#   complete returned for pseudo participant XXXXXX
#   completed sent for CC participant XXXXXX
#   completed received for CC participant XXXXXX
#   saved to disk transaction XXXXXX
#   JVM exit
#   created recovered CC/PC participant engine XXXXXX
#   created recovered CC/PC participant engine XXXXXX
#   created recovered CC/PC participant engine XXXXXX
#   created recovered CC/PC participant engine XXXXXX
#   created recovered CC/PC coordinator engine XXXXXX
#   created recovered CC/PC coordinator engine XXXXXX
#   created recovered CC/PC coordinator engine XXXXXX
#   created recovered CC/PC coordinator engine XXXXXX
#   reinstated prepared subordinate transaction XXXXXX
#   replaying commit for prepared transaction XXXXXX
#   send close for participant engine XXXXXX
#   received close for participant XXXXXX
#   send close for recovered CC/PC coordinator engine XXXXXX
#   received closed for recovered CC/PC coordinator engine XXXXXX
#   send close for participant engine XXXXXX
#   received close for participant XXXXXX
#   close called for pseudo participant XXXXXX
#   close called for subordinate coordinator XXXXXX
#   send close for participant engine XXXXXX
#   received close for participant XXXXXX
#   send close for recovered CC/PC coordinator engine XXXXXX
#   received closed for recovered CC/PC coordinator engine XXXXXX
#   send close for participant engine XXXXXX
#   received close for participant XXXXXX
#   send close for recovered CC/PC coordinator engine XXXXXX
#   received closed for recovered CC/PC coordinator engine XXXXXX
#   removed transaction XXXXXX
#   close returned for subordinate coordinator XXXXXX
#   close completed for pseudo participant XXXXXX
#   send close for recovered CC/PC coordinator engine XXXXXX
#   received closed for recovered CC/PC coordinator engine XXXXXX
#   removed transaction XXXXXX
#   JVM exit after removing both transactions
#

#####################################################################
#JBTM-1115 Rules
#

#####################################################################
# Setup counter MultiParticipantParticipantCompletionParticipantCloseTest
#
RULE setup counter subordinate.MultiParticipantParticipantCompletionParticipantCloseTest
CLASS org.jboss.jbossts.xts.servicetests.test.ba.subordinate.MultiParticipantParticipantCompletionParticipantCloseTest
METHOD run()
AT ENTRY
IF TRUE
DO debug("creating counter and rendezvous"),
   createCounter("closes", 3),
   createRendezvous("closes-complete", 2)
ENDRULE

#####################################################################
# Trigger Rendezvous after three calls to BACoordinator.complete()
#
RULE trigger rendezvous on complete
CLASS com.arjuna.mwlabs.wscf.model.sagas.arjunacore.BACoordinator
METHOD participantCompleted(String)
AT EXIT
IF (debug("decrementing") AND decrementCounter("closes") == 0)
DO debug("closes-complete, triggering rendezvous"),
   rendezvous("closes-complete")
ENDRULE

#####################################################################
# Wait on Rendezvous before calling uba.close() on MultiParticipantParticipantCompletionParticipantCloseTest
#
RULE wait for closes subordinate.MultiParticipantParticipantCompletionParticipantCloseTest
CLASS org.jboss.jbossts.xts.servicetests.test.ba.subordinate.MultiParticipantParticipantCompletionParticipantCloseTest
METHOD run()
AT CALL UserBusinessActivity.close()
IF TRUE
DO debug("waiting to call close"),
   rendezvous("closes-complete"),
   debug("rendezvous complete, calling close")
ENDRULE




#######################################################################
# This rule opens a file for the trace output during XTS startup
# It will be opened for append at reboot so messages from both runs
# will go to this file
#
RULE open trace file
CLASS org.jboss.jbossts.XTSService
METHOD start()
BIND NOTHING
IF TRUE
DO openTrace("log", "testlog")
ENDRULE

#######################################################################
# This rule resets the periodic recovery wait period to 10 seconds
# in order to speed up the test. Setting this any lower may result
# in unexpected behaviour
#
RULE reset periodic recovery wait time
CLASS com.arjuna.ats.arjuna.common.RecoveryEnvironmentBean
METHOD getPeriodicRecoveryPeriod()
AT ENTRY
IF TRUE
DO return 10
ENDRULE

#######################################################################
## rules for first run of AS

#######################################################################
# This rule is triggered when a non-recovered CC coordinator engine
# (CoordinatorCompletionCoordinatorEngine) is sent a close message. It exits the JVM,
# simulating a crash. The trigger location is on entry

RULE kill JVM at coordinator completion close
CLASS com.arjuna.wst11.messaging.engines.CoordinatorCompletionCoordinatorEngine
METHOD close
AT ENTRY
BIND engine:CoordinatorCompletionCoordinatorEngine = $0,
     recovered:boolean = engine.isRecovered(),
     identifier:String = engine.getId()
IF (NOT recovered)
   AND
   debug("close on non-recovered CC coordinator engine " + identifier)
DO traceln("log", "JVM exit"),
   debug("!!!killing JVM!!!"),
   killJVM()
ENDRULE

#######################################################################
# This rule is triggered when a non-recovered PC coordinator engine
# (ParticipantCompletionCoordinatorEngine) is sent a close message. It exits the JVM,
# simulating a crash. The trigger location is on entry

RULE kill JVM at participant completion close
CLASS com.arjuna.wst11.messaging.engines.ParticipantCompletionCoordinatorEngine
METHOD close
AT ENTRY
BIND engine:ParticipantCompletionCoordinatorEngine = $0,
     recovered:boolean = engine.isRecovered(),
     identifier:String = engine.getId()
IF (NOT recovered)
   AND
   debug("close on non-recovered PC coordinator engine " + identifier)
DO traceln("log", "JVM exit"),
   debug("!!!killing JVM!!!"),
   killJVM()
ENDRULE

#######################################################################
# This rule is triggered when a CC coordinator engine
# (CoordinatorCompletionCoordinatorEngine) is requested to send a complete message. It
# traces the call.

RULE trace send CC participant complete
CLASS com.arjuna.wst11.messaging.engines.CoordinatorCompletionCoordinatorEngine
METHOD complete
AFTER SYNCHRONIZE
BIND engine:CoordinatorCompletionCoordinatorEngine = $0,
     identifier:String = engine.getId()
IF TRUE
DO debug("complete sent for CC coordinator engine " + identifier),
   traceln("log", "complete sent for CC coordinator engine " + identifier)
ENDRULE

#######################################################################
# This rule is triggered when a CC coordinator engine
# (CoordinatorCompletionCoordinatorEngine) receives a completed message. It traces the call.

RULE trace receive CC participant completed
CLASS com.arjuna.wst11.messaging.engines.CoordinatorCompletionCoordinatorEngine
METHOD completed(NotificationType, MAP, ArjunaContext)
AT ENTRY
BIND engine:CoordinatorCompletionCoordinatorEngine = $0,
     identifier:String = engine.getId()
IF TRUE
DO debug("completed received for CC coordinator engine " + identifier),
   traceln("log", "completed received for CC coordinator engine " + identifier)
ENDRULE

#######################################################################
# This rule is triggered when a CC participant
# (CoordinatorCompletionParticipantEngine) receives a complete message. It
# traces the call.

RULE trace receive CC participant complete
CLASS com.arjuna.wst11.messaging.engines.CoordinatorCompletionParticipantEngine
METHOD complete
AFTER SYNCHRONIZE
BIND engine:CoordinatorCompletionParticipantEngine = $0,
     identifier:String = engine.getId()
IF TRUE
DO debug("complete received for CC participant " + identifier),
   traceln("log", "complete received for CC participant " + identifier)
ENDRULE

#######################################################################
# This rule is triggered when a CC participant
# (CoordinatorCompletionParticipantEngine) is requested to send a completed message. It
# traces the call.

RULE trace send CC participant completed
CLASS com.arjuna.wst11.messaging.engines.CoordinatorCompletionParticipantEngine
METHOD sendCompleted(boolean)
AT INVOKE sendCompleted
BIND engine:CoordinatorCompletionParticipantEngine = $0,
     identifier:String = engine.getId()
IF TRUE
DO debug("completed sent for CC participant " + identifier),
   traceln("log", "completed sent for CC participant " + identifier)
ENDRULE

#######################################################################
# This rule is triggered when a PC coordinator engine
# (ParticipantCompletionCoordinatorEngine) receives a completed message. It traces the call.

RULE trace receive participant completed
CLASS com.arjuna.wst11.messaging.engines.ParticipantCompletionCoordinatorEngine
METHOD completed(NotificationType, MAP, ArjunaContext)
AT ENTRY
BIND engine:ParticipantCompletionCoordinatorEngine = $0,
     identifier:String = engine.getId()
IF TRUE
DO debug("completed received for PC coordinator engine " + identifier),
   traceln("log", "completed received for PC coordinator engine " + identifier)
ENDRULE

#######################################################################
# This rule is triggered when a PC participant
# (ParticipantCompletionParticipantEngine) is requested to send a completed message. It
# traces the call.

RULE trace send participant completed
CLASS com.arjuna.wst11.messaging.engines.ParticipantCompletionParticipantEngine
METHOD sendCompleted(boolean)
AT INVOKE sendCompleted
BIND engine:ParticipantCompletionParticipantEngine = $0,
     identifier:String = engine.getId()
IF TRUE
DO debug("completed sent for PC participant " + identifier),
   traceln("log", "completed sent for PC participant " + identifier)
ENDRULE

#######################################################################
# This rule is triggered when a subordinate pseudo participant
# (SubordinateCoordinatorCompletionParticipantStub) is requested to send a completed message. It
# traces the call.

RULE trace subordinate participant stub complete
CLASS com.arjuna.wst11.stub.SubordinateCoordinatorCompletionParticipantStub
METHOD complete
AT ENTRY
BIND NOTHING
IF TRUE
DO debug("complete called for pseudo-participant " + $0),
   traceln("log", "complete called for pseudo-participant " + $0)
ENDRULE

#######################################################################
# This rule is triggered when a subordinate pseudo participant
# (SubordinateCoordinatorCompletionParticipantStub) has forwarded a complete message. It
# traces the call.

RULE trace subordinate participant stub complete 2
CLASS com.arjuna.wst11.stub.SubordinateCoordinatorCompletionParticipantStub
METHOD complete
AFTER INVOKE complete
BIND NOTHING
IF TRUE
DO debug("complete returned for pseudo-participant " + $0),
   traceln("log", "complete returned for pseudo-participant " + $0)
ENDRULE

#######################################################################
## rules for reboot run of AS

#######################################################################
# This rule is triggered when a CC coordinator engine (CoordinatorCompletionCoordinatorEngine)
# is created from details located in the log record. It traces the
# create operation. The trigger location is at entry but the rule
# should only be triggered after calling the super constructor

RULE trace CC coordinator engine create
CLASS com.arjuna.wst11.messaging.engines.CoordinatorCompletionCoordinatorEngine
METHOD <init>(String, W3CEndpointReference, State, boolean)
AT ENTRY
BIND identifier = $1,
     recovered=$4
IF recovered
DO debug("created recovered CC coordinator engine " + identifier),
   traceln("log", "created recovered CC coordinator engine " + identifier)
ENDRULE

#######################################################################
# This rule is triggered when a CC participant (CoordinatorCompletionParticipantEngine)
# is created from details located in the log record. It traces the
# create operation. The trigger location is at entry but the rule
# should only be triggered after calling the super constructor

RULE trace CC participant create
CLASS com.arjuna.wst11.messaging.engines.CoordinatorCompletionParticipantEngine
METHOD <init>(String, W3CEndpointReference, BusinessAgreementWithCoordinatorCompletionParticipant, State, boolean)
AT ENTRY
BIND identifier = $1,
     recovered=$5
IF recovered
DO debug("created recovered CC participant engine " + identifier),
   traceln("log", "created recovered CC participant engine " + identifier)
ENDRULE

#######################################################################
# This rule is triggered when a PC coordinator engine (ParticipantCompletionCoordinatorEngine)
# is created from details located in the log record. It traces the
# create operation. The trigger location is at entry but the rule
# should only be triggered after calling the super constructor

RULE trace PC coordinator engine create
CLASS com.arjuna.wst11.messaging.engines.ParticipantCompletionCoordinatorEngine
METHOD <init>(String, W3CEndpointReference, State, boolean)
AT ENTRY
BIND identifier = $1,
     recovered=$4
IF recovered
DO debug("created recovered PC coordinator engine " + identifier),
   traceln("log", "created recovered PC coordinator engine " + identifier)
ENDRULE

#######################################################################
# This rule is triggered when a PC participant (ParticipantCompletionParticipantEngine)
# is created from details located in the log record. It traces the
# create operation. The trigger location is at entry but the rule
# should only be triggered after calling the super constructor

RULE trace PC participant create
CLASS com.arjuna.wst11.messaging.engines.ParticipantCompletionParticipantEngine
METHOD <init>(String, W3CEndpointReference, BusinessAgreementWithParticipantCompletionParticipant, State, boolean)
AT ENTRY
BIND identifier = $1,
     recovered=$5
IF recovered
DO debug("created recovered PC participant engine " + identifier),
   traceln("log", "created recovered PC participant engine " + identifier)
ENDRULE

#######################################################################
# This rule is triggered when a recovered CC coordinator engine
# (CoordinatorCompletionCoordinatorEngine) is requested to send a close message. This
# happens during replay of a prepared TX from
# the log. It traces the call.

RULE trace send recovered CC participant close
CLASS com.arjuna.wst11.messaging.engines.CoordinatorCompletionCoordinatorEngine
METHOD close
AFTER SYNCHRONIZE
BIND engine:CoordinatorCompletionCoordinatorEngine = $0,
     recovered:boolean = engine.isRecovered(),
     identifier:String = engine.getId()
IF recovered
DO debug("send close for recovered CC coordinator engine " + identifier),
   traceln("log", "send close for recovered CC coordinator engine " + identifier)
ENDRULE

#######################################################################
# This rule is triggered when a recovered CC coordinator engine
# (CoordinatorCompletionCoordinatorEngine) receives a closed message. This
# happens during replay of a prepared TX from
# the log. It traces the call.

RULE trace receive recovered CC participant closed
CLASS com.arjuna.wst11.messaging.engines.CoordinatorCompletionCoordinatorEngine
METHOD closed
AFTER SYNCHRONIZE
BIND engine:CoordinatorCompletionCoordinatorEngine = $0,
     recovered:boolean = engine.isRecovered(),
     identifier:String = engine.getId()
IF recovered
DO debug("received closed for recovered CC coordinator engine " + identifier),
   traceln("log", "received closed for recovered CC coordinator engine " + identifier)
ENDRULE

#######################################################################
# This rule is triggered when a recovered CC participant engine
# (CoordinatorCompletionParticipantEngine) is requested to send a closed message. This
# happens during replay of a prepared TX from
# the log. It traces the call.

RULE trace send recovered participant closed
CLASS com.arjuna.wst11.messaging.engines.CoordinatorCompletionParticipantEngine
METHOD sendClosed
AT INVOKE sendClosed
BIND engine:CoordinatorCompletionParticipantEngine = $0,
     recovered:boolean = engine.isRecovered(),
     identifier:String = engine.getId()
IF recovered
DO debug("send closed for recovered CC participant engine " + identifier),
   traceln("log", "send closed for recovered CC participant engine " + identifier)
ENDRULE

#######################################################################
# This rule is triggered when a recovered CC participant engine
# (CoordinatorCompletionParticipantEngine) receives a close message. This
# happens during replay of a prepared TX from
# the log. It traces the call.

RULE trace receive recovered CC participant close
CLASS com.arjuna.wst11.messaging.engines.CoordinatorCompletionParticipantEngine
METHOD close
AFTER SYNCHRONIZE
BIND engine:CoordinatorCompletionParticipantEngine = $0,
     recovered:boolean = engine.isRecovered(),
     identifier:String = engine.getId()
IF recovered
DO debug("received close for recovered CC participant engine " + identifier),
   traceln("log", "received close for recovered CC participant engine " + identifier)
ENDRULE

#######################################################################
# This rule is triggered when a recovered PC coordinator engine
# (ParticipantCompletionCoordinatorEngine) is requested to send a close message. This
# happens during replay of a prepared TX from
# the log. It traces the call.

RULE trace send recovered PC participant close
CLASS com.arjuna.wst11.messaging.engines.ParticipantCompletionCoordinatorEngine
METHOD close
AFTER SYNCHRONIZE
BIND engine:ParticipantCompletionCoordinatorEngine = $0,
     recovered:boolean = engine.isRecovered(),
     identifier:String = engine.getId()
IF recovered
DO debug("send close for recovered PC coordinator engine " + identifier),
   traceln("log", "send close for recovered PC coordinator engine " + identifier)
ENDRULE

#######################################################################
# This rule is triggered when a recovered PC coordinator engine
# (CoordinatorCompletionCoordinatorEngine) receives a closed message. This
# happens during replay of a prepared TX from
# the log. It traces the call.

RULE trace receive recovered PC participant closed
CLASS com.arjuna.wst11.messaging.engines.ParticipantCompletionCoordinatorEngine
METHOD closed
AFTER SYNCHRONIZE
BIND engine:ParticipantCompletionCoordinatorEngine = $0,
     recovered:boolean = engine.isRecovered(),
     identifier:String = engine.getId()
IF recovered
DO debug("received closed for recovered PC coordinator engine " + identifier),
   traceln("log", "received closed for recovered PC coordinator engine " + identifier)
ENDRULE

#######################################################################
# This rule is triggered when a recovered participant engine PC
# (ParticipantCompletionParticipantEngine) is requested to send a closed message. This
# happens during replay of a prepared TX from
# the log. It traces the call.

RULE trace send recovered PC participant closed
CLASS com.arjuna.wst11.messaging.engines.ParticipantCompletionParticipantEngine
METHOD sendClosed
AT INVOKE sendClosed
BIND engine:ParticipantCompletionParticipantEngine = $0,
     recovered:boolean = engine.isRecovered(),
     identifier:String = engine.getId()
IF recovered
DO debug("send closed for recovered PC participant engine " + identifier),
   traceln("log", "send closed for recovered PC participant engine " + identifier)
ENDRULE

#######################################################################
# This rule is triggered when a recovered PC participant engine
# (CoordinatorCompletionParticipantEngine) receives a close message. This
# happens during replay of a prepared TX from
# the log. It traces the call.

RULE trace receive recovered PC participant close
CLASS com.arjuna.wst11.messaging.engines.ParticipantCompletionParticipantEngine
METHOD close
AFTER SYNCHRONIZE
BIND engine:ParticipantCompletionParticipantEngine = $0,
     recovered:boolean = engine.isRecovered(),
     identifier:String = engine.getId()
IF recovered
DO debug("received close for recovered PC participant engine " + identifier),
   traceln("log", "received close for recovered PC participant engine " + identifier)
ENDRULE

#######################################################################
# This rule is triggered when a subordinate pseudo participant
# (SubordinateCoordinatorCompletionParticipantStub) is requested to send a close message. It
# traces the call.

RULE trace subordinate participant stub close
CLASS com.arjuna.wst11.stub.SubordinateCoordinatorCompletionParticipantStub
METHOD close
AT ENTRY
BIND NOTHING
IF TRUE
DO debug("close called for pseudo-participant " + $0),
   traceln("log", "close called for pseudo-participant " + $0)
ENDRULE

#######################################################################
# This rule is triggered when a subordinate pseudo participant
# (SubordinateCoordinatorCompletionParticipantStub) forwards a close message to its subordinate
# coordinator during recovery. It traces the call.

RULE trace subordinate participant stub close forward
CLASS com.arjuna.wst11.stub.SubordinateCoordinatorCompletionParticipantStub
METHOD close
AT INVOKE close 2
BIND NOTHING
IF TRUE
DO debug("forwarding close for pseudo-participant " + $0 + " to subordinate coordinator"),
   traceln("log", "forwarding close for pseudo-participant " + $0 + " to subordinate coordinator")
ENDRULE

#######################################################################
# This rule is triggered when a subordinate pseudo participant
# (SubordinateCoordinatorCompletionParticipantStub) throws an error from its close method
# because the subordinate coordinator has not yet been recovered. It
# traces the throw.

RULE trace subordinate participant stub close with no coordinator
CLASS com.arjuna.wst11.stub.SubordinateCoordinatorCompletionParticipantStub
METHOD close
AT THROW 3
BIND NOTHING
IF TRUE
DO debug("throw during close for pseudo-participant " + $0 + " with no subordinate coordinator"),
   traceln("log", "throw during close for pseudo-participant " + $0 + " with no subordinate coordinator")
ENDRULE

#######################################################################
# This rule is triggered when a subordinate pseudo participant
# (SubordinateCoordinatorCompletionParticipantStub) throws an error from its close method
# because the subordinate coordinator has not yet been activated. It
# traces the throw.


RULE trace subordinate participant stub close close with unactivated coordinator
CLASS com.arjuna.wst11.stub.SubordinateCoordinatorCompletionParticipantStub
METHOD close
AT THROW 4
BIND NOTHING
IF TRUE
DO debug("throw during close for pseudo-participant " + $0 + " with unactivated subordinate coordinator"),
   traceln("log", "throw during close for pseudo-participant " + $0 + " with unactivated subordinate coordinator")
ENDRULE

#######################################################################
# This rule is triggered when a subordinate pseudo participant
# (SubordinateCoordinatorCompletionParticipantStub) throws an error from its close method
# because of a system exception being thrown from the close. It
# traces the throw.


RULE trace subordinate participant stub close close with system exception from coordinator
CLASS com.arjuna.wst11.stub.SubordinateCoordinatorCompletionParticipantStub
METHOD close
AT THROW 5
BIND NOTHING
IF TRUE
DO debug("throw during close for pseudo-participant " + $0 + " with system exception from subordinate coordinator"),
   traceln("log", "throw during close for pseudo-participant " + $0 + " with system exception from subordinate coordinator")
ENDRULE

#######################################################################
# This rule is triggered when a subordinate pseudo participant
# (SubordinateCoordinatorCompletionParticipantStub) returns from sending a close message. It
# traces the call.

RULE trace subordinate participant stub close return
CLASS com.arjuna.wst11.stub.SubordinateCoordinatorCompletionParticipantStub
METHOD close
AT EXIT
BIND NOTHING
IF TRUE
DO debug("close completed for pseudo-participant " + $0),
   traceln("log", "close completed for pseudo-participant " + $0)
ENDRULE

#######################################################################
# This rule is triggered when a subordinate coordinator
# (SubordinateBACoordinator) calsl prepare during completion. It
# traces the call.

RULE trace subordinate coordinator prepare
CLASS com.arjuna.mwlabs.wscf.model.sagas.arjunacore.subordinate.SubordinateBACoordinator
METHOD complete
AT INVOKE prepare
BIND uid = $0.get_uid()
IF TRUE
DO debug("prepare for transaction " + uid),
   traceln("log", "prepare for transaction " + uid)
ENDRULE

#######################################################################
# This rule is triggered when a subordinate coordinator
# (SubordinateCoordinator) is requested to perform a close. It
# traces the call.

RULE trace subordinate coordinator close
CLASS com.arjuna.mwlabs.wscf.model.sagas.arjunacore.subordinate.SubordinateBACoordinator
METHOD close
AT ENTRY
BIND NOTHING
IF TRUE
DO debug("close called for subordinate coordinator " + $0),
   traceln("log", "close called for subordinate coordinator " + $0)
ENDRULE

#######################################################################
# This rule is triggered when a subordinate coordinator
# (SubordinateCoordinator) is requested to perform a close. It
# traces the call.

RULE trace subordinate coordinator close 2
CLASS com.arjuna.mwlabs.wscf.model.sagas.arjunacore.subordinate.SubordinateBACoordinator
METHOD close
AT EXIT
BIND NOTHING
IF TRUE
DO debug("close returned for subordinate coordinator " + $0),
   traceln("log", "close returned for subordinate coordinator " + $0)
ENDRULE

#######################################################################
# This rule is triggered when the recovery system finds a PREPARED
# parent activity in the log and reruns the phase 2 commit operation.
# It prints a message which can be used to verify that the test has
# progressed as expected and creates a countdown used to detect exit of
# both transactions

RULE trace prepared replay
CLASS org.jboss.jbossts.xts.recovery.coordinator.ba.RecoveryBACoordinator
METHOD replayPhase2
AT INVOKE phase2Commit
BIND coordinator = $0,
     coordinatorId : CoordinatorId = coordinator.identifier(),
     status : int = coordinator.status()
IF (status == com.arjuna.ats.arjuna.coordinator.ActionStatus.PREPARED)
     OR
     (status == com.arjuna.ats.arjuna.coordinator.ActionStatus.COMMITTING)
DO debug("replaying commit for prepared transaction " + coordinatorId),
   traceln("log", "replaying commit for prepared transaction " + coordinatorId),
   createCountDown("exit countdown", 1)
ENDRULE

#######################################################################
# This rule is triggered when the recovery system finds a PREPARED
# subordinate activity in the log. It prints a message which can be
# used to verify that the test has progressed as expected

RULE trace subordinate prepared replay
CLASS org.jboss.jbossts.xts.recovery.coordinator.ba.RecoverySubordinateBACoordinator
METHOD replayPhase2
AT ENTRY
BIND coordinator = $0,
     coordinatorId : CoordinatorId = coordinator.identifier(),
     status : int = coordinator.status()
IF (status == com.arjuna.ats.arjuna.coordinator.ActionStatus.PREPARED)
     OR
     (status == com.arjuna.ats.arjuna.coordinator.ActionStatus.COMMITTING)
DO debug("reinstated prepared subordinate transaction " + coordinatorId),
   traceln("log", "reinstated prepared subordinate transaction " + coordinatorId)
ENDRULE

#######################################################################
# This rule is triggered when a TX is saved to disk during prepare.

RULE trace TX save at prepare
CLASS com.arjuna.ats.arjuna.coordinator.BasicAction
METHOD prepare(boolean)
AFTER CALL save_state
BIND action : BasicAction = $0,
     uid  = action.get_uid()
IF TRUE
DO traceln("log", "saved to disk transaction " + uid),
   debug("saved to disk transaction " + uid)
ENDRULE

#######################################################################
# activity from the log for the second time. It ensures that the JVM
# exits. n.b. it waits for the second delete because both the subordinate
# tx and the parent tx need to be deleted.

RULE trace remove committed state and exit JVM
CLASS com.arjuna.ats.arjuna.coordinator.BasicAction
METHOD updateState
AFTER CALL remove_committed
BIND action : BasicAction = $0,
     uid  = action.get_uid()
IF countDown("exit countdown")
DO traceln("log", "JVM exit after removing both transactions"),
   debug("JVM exit after removing both transactions"),
   killJVM()
ENDRULE

#######################################################################
# This rule is triggered when the recovery system deletes an
# activity from the log. It prints a message which can be used to
# verify that the test has completed.

RULE trace remove committed state
CLASS com.arjuna.ats.arjuna.coordinator.BasicAction
METHOD updateState
AFTER CALL remove_committed
BIND action : BasicAction = $0,
     uid  = action.get_uid()
IF TRUE
DO traceln("log", "removed transaction " + uid),
   debug("removed transaction " + uid)
ENDRULE
