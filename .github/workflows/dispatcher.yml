name: dispatcher

on:
  pull_request:
    types: [opened, edited, synchronize, reopened]
    
permissions:
  actions: write
  pull-requests: read
  contents: read

jobs:
  dispatcher:
    runs-on: ubuntu-latest

    outputs:
      workflowToRunMap: ${{ steps.parse.outputs.result }}
      pr_number: ${{ steps.set-pr-data.outputs.pr_number }}
      pr_ref: ${{ steps.set-pr-data.outputs.pr_ref }}
      pr_repo: ${{ steps.set-pr-data.outputs.pr_repo }}

    steps:
      - name: Extract PR metadata
        id: set-pr-data
        run: |
          echo "pr_number=${{ github.event.pull_request.number }}" >> $GITHUB_OUTPUT
          echo "pr_ref=${{ github.event.pull_request.head.ref }}" >> $GITHUB_OUTPUT
          echo "pr_repo=${{ github.event.pull_request.head.repo.full_name }}" >> $GITHUB_OUTPUT

      - name: Parse PR description and trigger workflows
        id: parse
        uses: actions/github-script@v8
        with:
          result-encoding: string
          script: |
            const pr = context.payload.pull_request;
            const prBody = pr.body || "";

            if (!prBody) {
              core.info('PR body is empty. No test will be started.');
              return JSON.stringify({});
            }

            if (prBody.includes('NO_TEST')) {
              core.info('PR description contains `NO_TEST`. Skipping testing axes.');
              return JSON.stringify({});
            }

            const workflowMap = {
              'CORE': 'core.yml',
              'AS_TESTS': 'as_tests.yml',
              'RTS': 'rts.yml',
              'XTS': 'xts.yml',
              'QA_JTA': 'qa_jta.yml'
            };

            // Convert "! AXIS" to "!AXIS"
            const processedBody = prBody.replace(/!\s+/g, '!');
            // Normalise description: replace newlines and commas with spaces and split the result into a set of tokens
            const tokens = new Set(processedBody.replace(/[\r\n,]/g, ' ').split(/\s+/));

            const workflowToRunMap = Object.fromEntries(
              Object.keys(workflowMap).map(k => [k, false])
            );

            for (const [axis, workflowFile] of Object.entries(workflowMap)) {
              if (tokens.has(axis) && !tokens.has(`!${axis}`)) {
                core.info(`Detected axis ${axis}. Will trigger ${workflowFile}`);
                workflowToRunMap[axis] = true;
              } else {
                core.info(`Axis ${axis} not requested or explicitly negated.`);
              }
            }

            return JSON.stringify(workflowToRunMap);

  CORE:
    needs: dispatcher
    if: ${{ fromJson(needs.dispatcher.outputs.workflowToRunMap).CORE }}
    uses: ./.github/workflows/core.yml
    with:
      pull_request_number: ${{ needs.dispatcher.outputs.pr_number }}
      pull_request_ref: ${{ needs.dispatcher.outputs.pr_ref }}
      pull_request_repo: ${{ needs.dispatcher.outputs.pr_repo }}

  AS_TESTS:
    needs: dispatcher
    if: ${{ fromJson(needs.dispatcher.outputs.workflowToRunMap).AS_TESTS }}
    uses: ./.github/workflows/as_tests.yml
    with:
      pull_request_number: ${{ needs.dispatcher.outputs.pr_number }}
      pull_request_ref: ${{ needs.dispatcher.outputs.pr_ref }}
      pull_request_repo: ${{ needs.dispatcher.outputs.pr_repo }}
  
  RTS:
    needs: dispatcher
    if: ${{ fromJson(needs.dispatcher.outputs.workflowToRunMap).RTS }}
    uses: ./.github/workflows/rts.yml
    with:
      pull_request_number: ${{ needs.dispatcher.outputs.pr_number }}
      pull_request_ref: ${{ needs.dispatcher.outputs.pr_ref }}
      pull_request_repo: ${{ needs.dispatcher.outputs.pr_repo }}

  XTS:
    needs: dispatcher
    if: ${{ fromJson(needs.dispatcher.outputs.workflowToRunMap).XTS }}
    uses: ./.github/workflows/xts.yml
    with:
      pull_request_number: ${{ needs.dispatcher.outputs.pr_number }}
      pull_request_ref: ${{ needs.dispatcher.outputs.pr_ref }}
      pull_request_repo: ${{ needs.dispatcher.outputs.pr_repo }}

  QA_JTA:
    needs: dispatcher
    if: ${{ fromJson(needs.dispatcher.outputs.workflowToRunMap).QA_JTA }}
    uses: ./.github/workflows/qa_jta.yml
    with:
      pull_request_number: ${{ needs.dispatcher.outputs.pr_number }}
      pull_request_ref: ${{ needs.dispatcher.outputs.pr_ref }}
      pull_request_repo: ${{ needs.dispatcher.outputs.pr_repo }}