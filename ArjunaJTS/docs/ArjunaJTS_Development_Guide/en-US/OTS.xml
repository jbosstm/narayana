<?xml version='1.0' encoding='utf-8' ?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [
<!ENTITY % BOOK_ENTITIES SYSTEM "ArjunaJTS_Development_Guide.ent">
%BOOK_ENTITIES;
]>
<chapter>
  <title>Introduction to the OTS</title>
  <para>
    Basic JBossTS programming involves using the OTS interfaces provided in the <systemitem>CosTransactions</systemitem>
    module, which is specified in <filename>CosTransactions.idl</filename>. This chapter is based on the <systemitem>OTS
    Specification1</systemitem>, specifically with the aspects of OTS that are valuable for developing OTS applications
    using JBossTS. Where relevant, each section describes JBossTS implementation decisions and runtime choices available
    to you. These choices are also summarized at the end of this chapter. Subsequent chapters illustrate using these
    interfaces to construct transactional applications.
  </para>

  <section>
    <title>Defining the OTS</title>
    <para>
      The raw <interfacename>CosTransactions</interfacename> interfaces reside in package
      <package>org.omg.CosTransactions</package>. The JBossTS implementations of these interfaces reside in package
      <package>com.arjuna.CosTransactions</package> and its sub-packages.
    </para>
    <para>
      You can override many run-time decisions of JBossTS Java properties specified at run-time. The property names are
      mentioned in the <classname>com.arjuna.ats.jts.common.Environment</classname> class.
    </para>
    <figure>
      <title>OTS architecture</title>
      <mediaobject>
        <imageobject>
          <imagedata fileref="images/ots_architecture.png" format="PNG"/>
        </imageobject>
        <textobject>
          <para>OTS architecture</para>
        </textobject>
      </mediaobject>
    </figure>

  </section>

  <section>
    <title>Action programming models</title>
    <para>
      A client application program can manage a transaction using direct or indirect context management.
    </para>
    <itemizedlist>
      <listitem>
        <para>
          <firstterm>Indirect context management</firstterm> means that an application uses the pseudo-object
          <classname>Current</classname>, provided by the Transaction Service, to associate the transaction context with
          the application thread of control.
        </para>
      </listitem>
      <listitem>
        <para>
          For <firstterm>direct context management</firstterm>, an application manipulates the
          <classname>Control</classname> object and the other objects associated with the transaction.
        </para>
      </listitem>
    </itemizedlist>
    <para>
      An object may require transactions to be either explicitly or implicitly propagated to its operations.
    </para>
    <itemizedlist>
      <listitem>
        <para>
          <firstterm>Explicit propagation</firstterm> means that an application propagates a transaction context by
          passing objects defined by the Transaction Service as explicit parameters. Typically the object is the
          <classname>PropagationContext</classname> structure.
        </para>
      </listitem>
      <listitem>
        <para>
          <firstterm>Implicit propagation</firstterm> means that requests are implicitly associated with the client’s
          transaction, by sharing the client's transaction context. The context is transmitted to the objects without
          direct client intervention. Implicit propagation depends on indirect context management, since it propagates
          the transaction context associated with the <classname>Current</classname> pseudo-object. An object that
          supports implicit propagation should not receive any Transaction Service object as an explicit parameter.
        </para>
      </listitem>
    </itemizedlist>
    <para>
      A client may use one or both forms of context management, and may communicate with objects that use either method
      of transaction propagation. This results in four ways in which client applications may communicate with
      transactional objects:
    </para>
    <variablelist>
      <varlistentry>
        <term>Direct Context Management/Explicit Propagation</term>
        <listitem>
          <para>
            The client application directly accesses the <classname>Control</classname> object, and the other objects
            which describe the state of the transaction. To propagate the transaction to an object, the client must
            include the appropriate Transaction Service object as an explicit parameter of an operation. Typically, the
            object is the <classname>PropagationContext</classname> structure.
          </para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>Indirect Context Management/Implicit Propagation</term>
        <listitem>
          <para>
            The client application uses operations on the <classname>Current</classname> pseudo-object to create and
            control its transactions. When it issues requests on transactional objects, the transaction context
            associated with the current thread is implicitly propagated to the object.
          </para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>Indirect Context Management/Explicit Propagation</term>
        <listitem>
          <para>
            for an implicit model application to use explicit propagation, it can get access to the Control using the
            get_control operation on the Current pseudo object. It can then use a Transaction Service object as an
            explicit parameter to a transactional object; for efficiency reasons this should be the PropagationContext
            structure, obtained by calling get_txcontext on the appropriate Coordinator reference. This is explicit
            propagation.
          </para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>Direct Context Management/Implicit Propagation</term>
        <listitem>
          <para>
            A client that accesses the Transaction Service objects directly can use the <methodname>resume</methodname>
            pseudo-object operation to set the implicit transaction context associated with its thread. This way, the
            client can invoke operations of an object that requires implicit propagation of the transaction context.
          </para>
        </listitem>
      </varlistentry>
    </variablelist>
    <para>
      The main difference between direct and indirect context management is the effect on the invoking thread’s
      transaction context. Indirect context management causes the thread’s transaction context to be modified
      automatically by the OTS. For instance, if method <methodname>begin</methodname> is called, the thread’s notion of
      the current transaction is modified to the newly-created transaction. When the transaction is terminated, the
      transaction previously associated with the thread, if one existed, is restored as the thread’s context. This
      assumes that subtransactions are supported by the OTS implementation.
    </para>
    <para>
      If you use direct management, no changes to the thread's transaction context are made by the OTS, leaving the
      responsibility to you.
    </para>
  </section>

  <section>
    <title>Interfaces</title>
    <table>
      <title>Interfaces</title>
      <tgroup cols="4">
        <colspec colwidth="85px"/>
        <colspec colwidth="75px"/>
        <colspec colwidth="170px"/>
        <colspec colwidth="115px"/>
        <thead>
          <row>
            <entry>Function</entry>
            <entry>Used by</entry>
            <entry>Direct context mgmt</entry>
            <entry>Indirect context mgmt</entry>
          </row>
        </thead>
        <tbody>
          <row>
            <entry><para>Create a transaction</para></entry>
            <entry><para>Transaction originator</para></entry>
            <entry><methodname>Factory::create</methodname><para><methodname>Control::get_terminator</methodname></para><para><methodname>Control::get_coordinator</methodname></para></entry>
            <entry><para>begin</para><para>set_timeout</para></entry>
          </row>
          <row>
            <entry>Terminate a transaction</entry>
            <entry><para>Transaction originator</para><para>(implicit)</para><para>All</para><para>(explicit)</para></entry>
            <entry><para><methodname>Terminator::commit</methodname></para><para><methodname>Terminator::rollback</methodname></para></entry>
            <entry>commit rollback</entry>
          </row>
          <row>
            <entry>Rollback transaction</entry>
            <entry>Server</entry>
            <entry><para><methodname>Terminator::rollback_only</methodname></para></entry>
            <entry><para><methodname>rollback_only</methodname></para></entry>
          </row>
          <row>
            <entry>Propagation of transaction to server</entry>
            <entry>Server</entry>
            <entry>Declaration of method parameter</entry>
            <entry><para><interfacename>TransactionalObject</interfacename></para></entry>
          </row>
          <row>
            <entry>Client control of transaction propagation to server</entry>
            <entry>All</entry>
            <entry>Request parameters</entry>
            <entry><para><methodname>get_control</methodname></para><para><methodname>suspend</methodname></para><para><methodname>resume</methodname></para></entry>
          </row>
          <row>
            <entry>Register with a transaction</entry>
            <entry>Recoverable Server</entry>
            <entry><para><methodname>Coordinator::register_resource</methodname></para></entry>
            <entry>N/A</entry>
          </row>
          <row>
            <entry>Miscellaneous</entry>
            <entry>All</entry>
            <entry><para><methodname>Coordinator::get_status</methodname></para><para><methodname>Coordinator::get_transaction_name</methodname></para><para><methodname>Coordinator::is_same_transaction</methodname></para><para><methodname>Coordinator::hash_transaction</methodname></para><para><methodname>get_status</methodname></para><para><methodname>get_transaction_name</methodname></para></entry>
            <entry><para>N/A</para></entry>
          </row>
        </tbody>
      </tgroup>
    </table>
    <note>
      <para>
        For clarity, subtransaction operations are not shown
      </para>
    </note>
  </section>

  <section>
    <title>Transaction factory</title>
    <para>
      The <interfacename>TransactionFactory</interfacename> interface allows the transaction originator to begin a
      top-level transaction. Subtransactions must be created using the <methodname>begin</methodname> method of
      <classname>Current</classname>, or the <methodname>create_subtransaction</methodname> method of the parent’s
      Coordinator.) Operations on the factory and <classname>Coordinator</classname> to create new transactions use
      direct context management, and therefore do not modify the calling thread’s transaction context.
    </para>
    <para>
      The <methodname>create</methodname> operation creates a new top-level transaction and returns its
      <classname>Control</classname> object, which you can use to manage or control participation in the new
      transaction. Method <methodname>create</methodname> takes a parameter that is is an application-specific timeout
      value, in seconds. If the transaction does not complete before this timeout elapses, it is rolled back. If the
      parameter is <literal>0</literal>, no application-specific timeout is established.
    </para>
    <note>
      <para>
        Subtransactions do not have a timeout associated with them.
      </para>
    </note>
    <para>
      The Transaction Service implementation allows the <classname>TransactionFactory</classname> to be a separate
      server from the application, shared by transactions clients, and which manages transactions on their
      behalf. However, the specification also allows the TransactionFactory to be implemented by an object within each
      transactional client. This is the default implementation used by JBossTS, because it removes the need for a
      separate service to be available in order for transactional applications to execute, and therefore reduces a point
      of failure.
    </para>
    <para>
      If your applications require a separate transaction manager, set the <varname>OTS_TRANSACTION_MANAGER</varname>
      environment variable to the value <literal>YES</literal>. The system locates the transaction manager server in a
      manner specific to the ORB being used. The server can be located in a number of ways.
    </para>
    <itemizedlist>
      <listitem>
        <para>
          Registration with a name server.
        </para>
      </listitem>
      <listitem>
        <para>
          Addition to the ORB’s initial references, using a JBossTS specific references file.
        </para>
      </listitem>
      <listitem>
        <para>
          The ORB’s specific location mechanism, if applicable.
        </para>
      </listitem>
    </itemizedlist>
    <section>
      <title>OTS configuration file</title>
      <para>
        Similar to the <methodname>resolve_initial_references</methodname>, JBossTS supports an initial reference file
        where you can store references for specific services, and use these references at runtime. The file,
        <filename>CosServices.cfg</filename>, consists of two columns, separated by a single space.
      </para>
      <itemizedlist>
        <listitem>
          <para>
            The service name, which is <literal>TransactionService</literal> in the case of the OTS server.
        </para>
        </listitem>
        <listitem>
          <para>
            The IOR
          </para>
        </listitem>
      </itemizedlist>
      <para>
        <filename>CosServices.cfg</filename> is usually located in the <filename>etc/</filename> directory of the
        JBossTS installation. The OTS server automatically registers itself in this file, creating it if necessary, if
        you use the configuration file mechanism. Stale information is also automatically removed. The Transaction
        Service locates <filename>CosServices.cfg</filename> at runtime, using the
        <classname>OrbPortabilityEnvironmentBean</classname> properties <varname>initialReferencesRoot</varname> and
        <varname>InitialReferencesFile</varname>. <varname>initialReferencesRoot</varname> names a directory, and
        defaults to the current working directory. <varname>initialReferencesFile</varname> refers to a file within the
        <varname>initialReferencesRoot</varname>, and defaults to the name <literal>CosServices.cfg</literal>.
      </para>
    </section>
    
    <section>
      <title>Name service</title>
      <para>
        If your ORB supports a name service, and you configure JBossTS to use it, the transaction manager is
        automatically registered with it.
      </para>
      
    </section>
    
    <section>
      <title>resolve_initial_references</title>
      <para>
        JBossTS does not support <methodname>resolve_initial_references</methodname>.
      </para>
      
    </section>
    
    <section>
      <title>Overriding the default location mechanisms</title>
      <para>
        You can override the default location mechanism with the <varname>RESOLVE_SERVICE</varname> property variable,
        which can have any of three possible values.
      </para>
      <informaltable>
        <tgroup cols="2">
          <colspec colwidth="150px"/>
          <colspec colwidth="290px"/>
          <tbody>
            <row>
              <entry>CONFIGURATION_FILE</entry>
              <entry><para>This is the default option, and directs the system to use the
              <filename>CosServices.cfg</filename> file.</para></entry>
            </row>
            <row>
              <entry>NAME_SERVICE</entry>
              <entry><para>JBossTS tries to use a name service to locate the transaction factory. If the ORB does not
              support the name service mechanism, JBossTS throws an exception.</para></entry>
            </row>
            <row>
              <entry>BIND_CONNECT</entry>
              <entry><para>JBossTS uses the ORB-specific bind mechanism. If the ORB does not support such a mechanism,
              JBossTS throws an exception.</para></entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>
      <para>
        If <literal>RESOLVE_SERVICE</literal> is specified when running the transaction factory, the factory registers
        itself with the specified resolution mechanism.
      </para>
    </section>
  </section>

  <section>
    <title>Transaction timeouts</title>
    <para>
      As of JBossTS 4.5, transaction timeouts are unified across all transaction components and are controlled by
      <application>ArjunaCore</application>. Refer to the <citetitle>ArjunaCore Development Guide</citetitle> for more
      information.
    </para>
  </section>

  <section>
    <title>Transaction contexts</title>
    <para>
      Transaction contexts are fundamental to the OTS architecture. Each thread is associated with a context in one of
      three ways.
    </para>
    <informaltable>
      <tgroup cols="2">
        <colspec colwidth="150px"/>
        <colspec colwidth="290px"/>
        <tbody>
          <row>
            <entry>Null</entry>
            <entry><para>The thread has no associated transaction.</para></entry>
          </row>
          <row>
            <entry>A transaction ID</entry>
            <entry>The thread is associated with a transaction.</entry>
          </row>
        </tbody>
      </tgroup>
    </informaltable>
    <para>
      Contexts may be shared across multiple threads. In the presence of nested transactions, a context remembers the
      stack of transactions started within the environment, so that the context of the thread can be restored to the
      state before the nested transaction started, when the nested transaction ends.  Threads most commonly use object
      <classname>Current</classname> to manipulate transactional information, which is represented by
      <classname>Control</classname> objects. <classname>Current</classname> is the broker between a transaction and
      <classname>Control</classname> objects.
    </para>
    <para>
      Your application can manage transaction contexts either directly or indirectly. In the direct approach, the
      transaction originator issues a request to a <classname>TransactionFactory</classname> to begin a new top-level
      transaction. The factory returns a <classname>Control</classname> object that enables both a
      <interfacename>Terminator</interfacename> interface and a <interfacename>Coordinator</interfacename>
      interface. <interfacename>Terminator</interfacename> ends a
      transaction. <interfacename>Coordinator</interfacename> associates a thread with a transaction, or begins a nested
      transaction. You need to pass each interface as an explicit parameter in invocations of operations, because
      creating a transaction with them does not change a thread's current context. If you use the factory, and need to
      set the current context for a thread to the context which its control object returns, use the
      <methodname>resume</methodname> method of interface <interfacename>Current</interfacename>.
    </para>
    <example>
      <title>Interfaces <interfacename>Terminator</interfacename>, <interfacename>Coordinator</interfacename>, and
      <interfacename>Control</interfacename></title>
      <programlisting language="Java" role="JAVA"><xi:include href="extras/terminator_coordinator_control.java" xmlns:xi="http://www.w3.org/2001/XInclude" parse="text" /></programlisting>
    </example>
    <para>
      When the factory creates a transaction, you can specify a timeout value in seconds. If the transaction times out,
      it is subject to possible roll-back. Set the timeout to <literal>0</literal> to disable application-specific
      timeout.
    </para>
    <para>
      The <interfacename>Current</interfacename> interface handles implicit context management. Implicit context
      management provides simplified transaction management functionality, and automatically creates nested transactions
      as required. Transactions created using <interfacename>Current</interfacename> do not alter a thread’s current
      transaction context.
    </para>
    <example>
      <title>Interface <interfacename>Current</interfacename></title>
      <programlisting language="Java" role="JAVA"><xi:include href="extras/Current.java" xmlns:xi="http://www.w3.org/2001/XInclude" parse="text" /></programlisting>
    </example>
    
    <section>
      <title>Nested transactions</title>
      <para>
        Subtransactions are a useful mechanism for two reasons:
      </para>
      <variablelist>
        <varlistentry>
          <term>fault-tolerance</term>
          <listitem>
            <para>
              If a subtransaction rolls back, the enclosing transaction does not also need to roll back. This preserves
              as much of the work done so far, as possible.
            </para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>modularity</term>
          <listitem>
            <para>
              Indirect transaction management does not require special syntax for creating subtransactions. Begin a
              transaction, and if another transaction is associated with the calling thread, the new transaction is
              nested within the existing one. If you know that an object requires transactions, you can use them within
              the object. If the object's methods are invoked without a client transaction, the object's transaction is
              top-level. Otherwise, it is nested within the client's transaction. A client does not need to know whether
              an object is transactional.
            </para>
          </listitem>
        </varlistentry>
      </variablelist>
      <para>
        The outermost transaction of the hierarchy formed by nested transactions is called the top-level
        transaction. The inner components are called subtransactions. Unlike top-level transactions, the commits of
        subtransactions depend upon the commit/rollback of the enclosing transactions. Resources acquired within a
        subtransaction should be inherited by parent transactions when the top-level transaction completes. If a
        subtransaction rolls back, it can release its resources and undo any changes to its inherited resources.
      </para>
      <para>
        In the OTS, subtransactions behave differently from top-level transactions at commit time. Top-level
        transactions undergo a two-phase commit protocol, but nested transactions do not actually perform a commit
        protocol themselves. When a program commits a nested transaction, it only informs registered resources of its
        outcome. If a resource cannot commit, an exception is thrown, and the OTS implementation can ignore the
        exception or roll back the subtransaction. You cannot roll back a subtransaction if any resources have been
        informed that the transaction committed.
      </para>
    </section>

    <section>
      <title>Transaction propagation</title>
      <para>
        The OTS supports both implicit and explicit propagation of transactional behavior.
      </para>
      <itemizedlist>
        <listitem>
          <para>
            Implicit propagation means that an operation signature specifies no transactional behavior, and each
            invocation automatically sends transaction context associated with the calling thread.
          </para>
        </listitem>
        <listitem>
          <para>
            Explicit propagation means that applications must define their own mechanism for propagating
            transactions. This has the following features:
          </para>
          <itemizedlist>
            <listitem>
              <para>
                A client to control if its transaction is propagated with any operation invocation.
              </para>
            </listitem>
            <listitem>
              <para>
                A client can invoke operations on both transactional and non-transactional objects within a transaction.
              </para>
            </listitem>
          </itemizedlist>
        </listitem>
      </itemizedlist>
      <para>
        Transaction context management and transaction propagation are different things that may be controlled
        independently of each other. Mixing of direct and indirect context management with implicit and explicit
        transaction propagation is supported. Using implicit propagation requires cooperation from the ORB.  The client
        must send current context associated with the thread with any operation invocations, and the server must extract
        them before calling the targeted operation.
      </para>
      <para>
        If you need implicit context propagation, ensure that JBossTS is correctly initialized before you create
        objects. Both client and server must agree to use implicit propagation. To use implicit context propagation,
        your ORB needs to support filters or interceptors, or the <interfacename>CosTSPortability</interfacename>
        interface.
      </para>
      <informaltable>
        <tgroup cols="2">
          <colspec colwidth="150px"/>
          <colspec colwidth="290px"/>
          <tbody>
            <row>
              <entry>Implicit context propagation</entry>  
              <entry><para>Property variable <varname>OTS_CONTEXT_PROP_MODE</varname> set to
              <literal>CONTEXT</literal>.</para></entry>
            </row>
            <row>
              <entry>Interposition</entry>
              <entry><para>Property variable <varname>OTS_CONTEXT_PROP_MODE</varname> set to
              <literal>INTERPOSITION</literal>.</para></entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>
      <important>
        <para>
          Interposition is required to use the JBossTS Advanced API.
        </para>
      </important>
    </section>

    <section>
      <title>Examples</title>
      <example>
        <title>Simple transactional client using direct context management and explicit transaction propagation</title>
        <programlisting language="Java" role="JAVA"><xi:include href="extras/simple_transactional_client.java" xmlns:xi="http://www.w3.org/2001/XInclude" parse="text" /></programlisting>
      </example>
      <para>
        The next example rewrites the same program to use indirect context management and implicit propagation. This
        example is considerably simpler, because the application only needs to start and either commit or abort actions.
      </para>
      <example>
        <title>Indirect context management and implicit propagation</title>
        <programlisting language="Java" role="JAVA"><xi:include href="extras/simple_transactional_client_2.java" xmlns:xi="http://www.w3.org/2001/XInclude" parse="text" /></programlisting>
      </example>
      <para>
        The last example illustrates the flexibility of OTS by using both direct and indirect context management in
        conjunction with explicit and implicit transaction propagation.
      </para>
      <example>
        <title>Direct and direct context management with explicitly and implicit propagation</title>
        <programlisting language="Java" role="JAVA"><xi:include href="extras/simple_transactional_client_3.java" xmlns:xi="http://www.w3.org/2001/XInclude" parse="text" /></programlisting>
      </example>
    </section>

  </section>

  <section>
    <title>Transaction controls</title>
    <para>
      The <interfacename>Control</interfacename> interface allows a program to explicitly manage or propagate a
      transaction context. An object supporting the <interfacename>Control</interfacename> interface is associated with
      one specific transaction. The <interfacename>Control</interfacename> interface supports two operations:
      <methodname>get_terminator</methodname> and
      <methodname>get_coordinator</methodname>. <methodname>get_terminator</methodname> returns an instance of the
      <interfacename>Terminator</interfacename> interface.  <methodname>get_coordinator</methodname> returns an instance
      of the <interfacename>Coordinator</interfacename> interface. Both of these methods throw the
      <systemitem>Unavailable</systemitem> exception if the <interfacename>Control</interfacename> cannot provide the
      requested object. The OTS implementation can restrict the ability to use the Terminator and Coordinator in other
      execution environments or threads. At a minimum, the creator must be able to use them.
    </para>
    <para>
      Obtain the <methodname>Control</methodname> object for a transaction when it is created either by using either the
      <methodname>TransactionFactory</methodname> or <methodname>create_subtransaction</methodname> methods defined by
      the <interfacename>Coordinator</interfacename> interface. Obtain a <classname>Control</classname> for the
      transaction associated with the current thread using the <methodname>get_control</methodname> or
      <methodname>suspend</methodname> methods defined by the <interfacename>Current</interfacename> interface.
    </para>
    
    <section id="control-JBossTS-specifics">
      <title>JBossTS specifics</title>
      <para>
        The transaction creator must be able to use its <interfacename>Control</interfacename>, but the OTS
        implementation decides whether other threads can use <interfacename>Control</interfacename>. JBossTS places no
        restrictions the users of the <interfacename>Control</interfacename>.
      </para>
      <para>
        The OTS specification does not provide a means to indicate to the transaction system that information and
        objects associated with a given transaction can be purged from the system. In JBossTS, the
        <interfacename>Current</interfacename> interface destroys all information about a transaction when it
        terminates. For that reason, do not use any <interfacename>Control</interfacename> references to the transaction
        after it commits or rolls back.
      </para>
      <para>
        However, if the transaction is terminated using the Terminator interface, it is up to the programmer to signal
        that the transaction information is no longer required: this can be done using the destroyControl method of the
        OTS class in the com.arjuna.CosTransactions package. Once the program has indicated that the transaction
        information is no longer required, the same restrictions on using Control references apply as described
        above. If destroyControl is not called then transaction information will persist until garbage collected by the
        Java runtime.
      </para>
      <para>
        In JBossTS, you can propagate <interfacename>Coordinators</interfacename> and
        <interfacename>Terminators</interfacename> between execution environments.
      </para>
    </section>

  </section>

  <section>
    <title>The <interfacename>Terminator</interfacename> interface</title>
    <para>
      The <interfacename>Terminator</interfacename> interface supports <methodname>commit</methodname> and
      <methodname>rollback</methodname> operations. Typically, the transaction originator uses these operations.  Each
      object supporting the Terminator interface is associated with a single transaction. Direct context management via
      the Terminator interface does not change the client thread’s notion of the current transaction.
    </para>
    <para>
      The <methodname>commit</methodname> operation attempts to commit the transaction. To successfully commit, the
      transaction must not be marked <literal>rollback only</literal>, and all of its must participants agree to
      commit. Otherwise, the <systemitem>TRANSACTION_ROLLEDBACK</systemitem> exception is thrown. If the
      <varname>report_heuristics</varname> parameter is <literal>true</literal>, the Transaction Service reports
      inconsistent results using the <systemitem>HeuristicMixed</systemitem> and
      <systemitem>HeuristicHazard</systemitem> exceptions.
    </para>
    <para>
      When a transaction is committed, the coordinator drives any registered <classname>Resources</classname> using
      their <methodname>prepare</methodname> or <methodname>commit</methodname> methods. These Resources are responsible
      to ensure that any state changes to recoverable objects are made permanent, to guarantee the ACID properties.
    </para>
    <para>
      When <methodname>rollback</methodname> is called, the registered <classname>Resources</classname> need to
      guarantee that all changes to recoverable objects made within the scope of the transaction, and its descendants,
      is undone. All resources locked by the transaction are made available to other transactions, as appropriate to the
      degree of isolation the resources enforce.
    </para>
    
    <section>
      <title>JBossTS specifics</title>
      <para>
        See <xref linkend="control-JBossTS-specifics"/> for how long <interfacename>Terminator</interfacename>
        references remain valid after a transaction terminates.
      </para>
      <para>
        When a transaction is committing, it must make certain state changes persistent, so that it can recover if a
        failure occurs, and continue to commit, or rollback. To guarantee ACID properties, flush these state changes to
        the persistence store implementation before the transaction proceeds to commit. Otherwise, the application may
        assume that the transaction has committed, when the state changes may still volatile storage, and may be lost by
        a subsequent hardware failure. By default, JBossTS makes sure that such state changes are flushed. However,
        these flushes can impose a significant performance penalty to the application. To prevent transaction state
        flushes, set the <varname>TRANSACTION_SYNC</varname> variable to <literal>OFF</literal>. Obviously, do this at
        your own risk.
      </para>
      <para>
        When a transaction commits, if only a single resource is registered, the transaction manager does not need to
        perform the two-phase protocol. A single phase commit is possible, and the outcome of the transaction is
        determined by the resource. In a distributed environment, this optimization represents a significant performance
        improvement. As such, JBossTS defaults to performing single phase commit in this situation. Override this
        behavior at runtime by setting the <varname>COMMIT_ONE_PHASE</varname> property variable to
        <literal>NO</literal>.
      </para>
    </section>

  </section>

  <section>
    <title>The <interfacename>Coordinator</interfacename> interface</title>
    <para>
      The Coordinator interface is returned by the <methodname>get_coordinator</methodname> method of the
      <interfacename>Control</interfacename> interface. It supports the operations resources need to participate in a
      transaction. These participants are usually either recoverable objects or agents of recoverable objects, such as
      subordinate coordinators. Each object supporting the <interfacename>Coordinator</interfacename> interface is
      associated with a single transaction. Direct context management via the Coordinator interface does not change the
      client thread’s notion of the current transaction. You can terminate transaction directly, through the
      <interfacename>Terminator</interfacename> interface. In that case, trying to terminate the transaction a second
      time using <interfacename>Current</interfacename> causes an exception to be thrown for the second termination
      attempt.
    </para>
    <para>
      The operations supported by the Coordinator interface of interest to application programmers are:
    </para>

    <table>
      <title>Operations supported by the <interfacename>Coordinator</interfacename> interface</title>
      <tgroup cols="2">
        <colspec colwidth="150px"/>
        <colspec colwidth="290px"/>
        <tbody>
          <row>
            <entry>
              <para>
                <methodname>get_status</methodname>
              </para>
              <para>
                <methodname>get_parent_status</methodname>
              </para>
              <para>
                <methodname>get_top_level_status</methodname>
              </para>
            </entry>
            <entry>
              <para>
                Return the status of the associated transaction. At any given time a transaction can have one of the
                following status values representing its progress:
              </para>
              <variablelist>
                <varlistentry>
                  <term>StatusActive</term>
                  <listitem>
                    <para>
                      The transaction is currently running, and has not been asked to prepare or marked for rollback.
                    </para>
                  </listitem>
                </varlistentry>
                <varlistentry>
                  <term>StatusMarkedRollback</term>
                  <listitem>
                    <para>
                      The transaction is marked for rollback.
                    </para>
                  </listitem>
                </varlistentry>
                <varlistentry>
                  <term>StatusPrepared</term>
                  <listitem>
                    <para>
                      The transaction has been prepared, which means that all subordinates have responded
                      <classname>VoteCommit</classname>.
                    </para>
                  </listitem>
                </varlistentry>
                <varlistentry>
                  <term>StatusCommitted</term>
                  <listitem>
                    <para>
                      The transaction has committed. It is likely that heuristics exist. Otherwise, the transaction
                      would have been destroyed and <classname>StatusNoTransaction</classname> returned.
                    </para>
                  </listitem>
                </varlistentry>
                <varlistentry>
                  <term>StatusRolledBack</term>
                  <listitem>
                    <para>
                      The transaction has rolled back. It is likely that heuristics exist. Otherwise. the transaction
                      would have been destroyed and StatusNoTransaction returned.
                    </para>
                  </listitem>
                </varlistentry>
                <varlistentry>
                  <term>StatusUnknown</term>
                  <listitem>
                    <para>
                      The Transaction Service cannot determine the current status of the transaction. This is a
                      transient condition, and a subsequent invocation should return a different status.
                    </para>
                  </listitem>
                </varlistentry>
                <varlistentry>
                  <term>StatusNoTransaction</term>
                  <listitem>
                    <para>
                      No transaction is currently associated with the target object. This occurs after a transaction
                      completes.
                    </para>
                  </listitem>
                </varlistentry>
                <varlistentry>
                  <term>StatusPreparing</term>
                  <listitem>
                    <para>
                      The transaction is in the process of preparing and the final outcome is not known.
                    </para>
                  </listitem>
                </varlistentry>
                <varlistentry>
                  <term>StatusCommitting</term>
                  <listitem>
                    <para>
                      The transaction is in the process of committing.
                    </para>
                  </listitem>
                </varlistentry>
                <varlistentry>
                  <term>StatusRollingBack</term>
                  <listitem>
                    <para>
                      The transaction is in the process of rolling back.
                    </para>
                  </listitem>
                </varlistentry>
              </variablelist>
            </entry>
          </row>
          <row>
            <entry>
              <para>
                <methodname>is_same_transaction</methodname> and others  
              </para>
            </entry>
            <entry>
              <para>
                You can use these operations for transaction comparison. Resources may use these various operations to
                guarantee that they are registered only once with a specific transaction.
              </para>
            </entry>
          </row>
          <row>
            <entry>
              <para>
                <methodname>hash_transaction</methodname>
              </para>
              <para>
                <methodname>hash_top_level_tran</methodname>
              </para>
            </entry>
            <entry>
              <para>
                Returns a hash code for the specified transaction.
              </para>
            </entry>
          </row>
          <row>
            <entry>
              <para>
                <methodname>register_resource</methodname>
              </para>
            </entry>
            <entry>
              <para>
                Registers the specified Resource as a participant in the transaction. The
                <systemitem>Inactive</systemitem> exception is raised if the transaction is already prepared. The
                <systemitem>TRANSACTION_ROLLEDBACK</systemitem> exception is raised if the transaction is marked
                <literal>rollback only</literal>. If the <classname>Resource</classname> is a
                <classname>SubtransactionAwareResource</classname> and the transaction is a subtransaction, this
                operation registers the resource with this transaction and indirectly with the top-level transaction
                when the subtransaction’s ancestors commit. Otherwise, the resource is only registered with the current
                transaction. This operation returns a <classname>RecoveryCoordinator</classname> which this
                <classname>Resource</classname> can use during recovery. No ordering of registered Resources is implied
                by this operation. If <varname>A</varname> is registered after <varname>B</varname>, the OTS can operate
                on them in any order when the transaction terminates. Therefore, do not assume such an ordering exists
                in your implementation.
              </para>
            </entry>
          </row>
          <row>
            <entry>register_subtran_aware</entry>
            <entry>
              <para>
                Registers the specified subtransaction-aware resource with the current transaction, so that it know when
                the subtransaction commits or rolls back. This method cannot register the resource as a participant in
                the top-level transaction. The <systemitem>NotSubtransaction</systemitem> exception is raised if the
                current transaction is not a subtransaction. As with <methodname>register_resource</methodname>, no
                ordering is implied by this operation.
              </para>
            </entry>
          </row>
          <row>
            <entry>register_synchronization</entry>
            <entry>
              <para>
                Registers the <classname>Synchronization</classname> object with the transaction so that will be invoked
                before <methodname>prepare</methodname> and after the transaction completes. Synchronizations can only
                be associated with top-level transactions, and the <systemitem>SynchronizationsUnavailable</systemitem>
                exception is raised if you try to register a Synchronization with a subtransaction. As with
                <methodname>register_resource</methodname>, no ordering is implied by this operation.
              </para>
            </entry>
          </row>
          <row>
            <entry>rollback_only</entry>
            <entry>
              <para>
                Marks the transaction so that the only possible outcome is for it to rollback. The Inactive exception is
                raised if the transaction has already been prepared/completed.
              </para>
            </entry>
          </row>
          <row>
            <entry>create_subtransaction</entry>
            <entry>
              <para>
                A new subtransaction is created. Its parent is the current transaction. The
                <systemitem>Inactive</systemitem> exception is raised if the current transaction has already been
                prepared or completed. If you configure the Transaction Service without subtransaction support, the
                <systemitem>SubtransactionsUnavailable</systemitem> exception is raised.
              </para>
            </entry>
          </row>
        </tbody>
      </tgroup>
    </table>

    <section>
      <title>JBossTS specifics</title>
      <para>
        See <xref linkend="control-JBossTS-specifics" /> to control how long <interfacename>Coordinator</interfacename>
        references remain valid after a transaction terminates.
      </para>
      <note>
        <para>
          To disable subtransactions, set set the <varname>OTS_SUPPORT_SUBTRANSACTIONS</varname> property variable to
          <literal>NO</literal>.
        </para>
      </note>
    </section>
  </section>

  <section>
    <title>Heuristics</title>
    <para>
      The OTS permits individual resources to make heuristic decisions. <firstterm>Heuristic</firstterm> decisions are
      unilateral decisions made by one or more participants to commit or abort the transaction, without waiting for the
      consensus decision from the transaction service. Use heuristic decisions with care and only in exceptional
      circumstances, because they can lead to a loss of integrity in the system. If a participant makes a heuristic
      decision, an appropriate exception is raised during commit or abort processing.
    </para>
    <table>
      <title>Possible heuristic outcomes</title>
      <tgroup cols="2">
        <colspec colwidth="150px"/>
        <colspec colwidth="290px"/>
        <tbody>
          <row>
            <entry>HeuristicRollback</entry>
            <entry>
              <para>
                Raised on an attempt to commit, to indicate that the resource already unilaterally rolled back the
                transaction.
              </para>
            </entry>
          </row>
          <row>
            <entry>HeuristicCommit</entry>
            <entry>
              <para>
                Raised on an attempt to roll back, to indicate that the resource already unilaterally committed the
                transaction.
              </para>
            </entry>
          </row>
          <row>
            <entry>HeuristicMixed</entry>
            <entry>
              <para>
                Indicates that a heuristic decision has been made. Some updates committed while others rolled back.
              </para>
            </entry>
          </row>
          <row>
            <entry>HeuristicHazard</entry>
            <entry>
              <para>
                Indicates that a heuristic decision may have been made, and the outcome of some of the updates is
                unknown. For those updates which are known, they either all committed or all rolled back.
              </para>
            </entry>
          </row>
        </tbody>
      </tgroup>
    </table>
    <para>
      HeuristicMixed takes priority over HeuristicHazard. Heuristic decisions are only reported back to the originator
      if the <parameter>report_heuristics</parameter> argument is set to <literal>true</literal> when you invoke the
      commit operation.
    </para>
    
  </section>
  
  <section>
    <title>Current</title>
    <para>
      The <interfacename>Current</interfacename> interface defines operations that allow a client to explicitly manage
      the association between threads and transactions, using indirect context management. It defines operations that
      simplify the use of the Transaction Service.
    </para>
    <table>
      <title>Methods of <interfacename>Current</interfacename></title>
      <tgroup cols="2">
        <colspec colwidth="150px"/>
        <colspec colwidth="290px"/>
        <tbody>
          <row>
            <entry>begin</entry>
            <entry>
              <para>
                Creates a new transaction and associates it with the current thread. If the client thread is currently
                associated with a transaction, and the OTS implementation supported nested transactions, the new
                transaction becomes a subtransaction of that transaction. Otherwise, the new transaction is a top-level
                transaction. If the OTS implementation does not support nested transactions, the
                <systemitem>SubtransactionsUnavailable</systemitem> exception is thrown. The thread’s notion of the
                current context is modified to be this transaction.
              </para>
            </entry>
          </row>
          <row>
            <entry>commit</entry>
            <entry>
              <para>
                Commits the transaction. If the client thread does not have permission to commit the transaction, the
                standard exception <systemitem>NO_PERMISSION</systemitem> is raised. The effect is the same as
                performing the <methodname>commit</methodname> operation on the corresponding
                <classname>Terminator</classname> object. The client thread's transaction context is returned to its
                state before the <methodname>begin</methodname> request was initiated.
              </para>
            </entry>
          </row>
          <row>
            <entry>rollback</entry>
            <entry>
              <para>
                Rolls back the transaction. If the client thread does not have permission to terminate the transaction,
                the standard exception <systemitem>NO_PERMISSION</systemitem> is raised. The effect is the same as
                performing the <methodname>rollback</methodname> operation on the corresponding
                <classname>Terminator</classname> object. The client thread's transaction context is returned to its
                state before the <methodname>begin</methodname> request was initiated.
              </para>
            </entry>
          </row>
          <row>
            <entry>rollback_only</entry>
            <entry>
              <para>
                Limits the transaction's outcome to rollback only. If the transaction has already been terminated, or is
                in the process of terminating, an appropriate exception is thrown.
              </para>
            </entry>
          </row>
          <row>
            <entry>get_status</entry>
            <entry>
              <para>
                Returns the status of the current transaction, or exception <systemitem>StatusNoTransaction</systemitem>
                if no transaction is associated with the thread.
              </para>
            </entry>
          </row>
          <row>
            <entry>set_timeout</entry>
            <entry>
              <para>
                Modifies the timeout associated with top-level transactions for subsequent
                <methodname>begin</methodname> requests, for this thread only. Subsequent transactions are subject to
                being rolled back if they do not complete before the specified number of seconds elapses. Default
                timeout values for transactions without explicitly-set timeouts are implementation-dependent. JBossTS
                uses a value of <literal>0</literal>, which results in transactions never timing out. There is no
                interface in the OTS for obtaining the current timeout associated with a thread. However, JBossTS
                provides additional support for this. See <xref linkend="current-jbossts-specific" />.
              </para>
            </entry>
          </row>
          <row>
            <entry>get_control</entry>
            <entry>
              <para>
                Obtains a <classname>Control</classname> object representing the current transaction.  If the client
                thread is not associated with a transaction, a null object reference is returned. The operation is not
                dependent on the state of the transaction. It does not raise the
                <systemitem>TRANSACTION_ROLLEDBACK</systemitem> exception.
              </para>
            </entry>
          </row>
          <row>
            <entry>suspend</entry>
            <entry>
              <para>
                Obtains an object representing a transaction's context. If the client thread is not associated with a
                transaction, a null object reference is returned. You can pass this object to the
                <methodname>resume</methodname> operation to re-establish this context in a thread. The operation is not
                dependent on the state of the transaction. It does not raise the
                <systemitem>TRANSACTION_ROLLEDBACK</systemitem> exception. When this call returns, the current thread
                has no transaction context associated with it.
              </para>
            </entry>
          </row>
          <row>
            <entry>resume</entry>
            <entry>
              <para>
                Associates the client thread with a transaction. If the parameter is a null object reference, the
                client thread becomes associated with no transaction. The thread loses association with any previous
                transactions.
              </para>
            </entry>
          </row>
        </tbody>
      </tgroup>
    </table>
    <figure>
      <title>Creation of a top-level transaction using <interfacename>Current</interfacename></title>
      <mediaobject>
        <imageobject>
          <imagedata fileref="images/top_level_transaction_current.png" format="PNG"/>
        </imageobject>
        <textobject>
          <para>Creation of a top-level transaction using <interfacename>Current</interfacename></para>
        </textobject>
      </mediaobject>
    </figure>
    <figure>
      <title>Creation of a transaction using <interfacename>Current</interfacename></title>
      <mediaobject>
        <imageobject>
          <imagedata fileref="images/subtransaction_current.png" format="PNG"/>
        </imageobject>
        <textobject>
          <para>Creation of a subtransaction using <interfacename>Current</interfacename></para>
        </textobject>
      </mediaobject>
    </figure>

    <section id="current-jbossts-specific">
      <title>JBossTS specifics</title>
      <para>
        Ideally, you should Obtain <interfacename>Current</interfacename> by using the life-cycle service factory
        finder. However, very few ORBs support this. JBossTS provides method <methodname>get_current</methodname> of
        <interfacename>Current</interfacename> for this purpose. This class hides any ORB-specific mechanisms required
        for obtaining <interfacename>Current</interfacename>.
      </para>
      <para>
        If no timeout value is associated with <interfacename>Current</interfacename>, JBossTS associates no timeout
        with the transaction. The current OTS specification does not provide a means whereby the timeout associated with
        transaction creation can be obtained. However, JBossTS Current supports a get_timeout method.
      </para>
      <para>
        By default, the JBossTS implementation of <interfacename>Current</interfacename> does not use a separate
        <classname>TransactionFactory</classname> server when creating new top-level transactions. Each transactional
        client has a <classname>TransactionFactory</classname> co-located with it. Override this by setting the
        <varname>OTS_TRANSACTION_MANAGER</varname> variable to <literal>YES</literal>.
      </para>
      <para>
        The transaction factory is located in the <filename>bin/</filename> directory of the JBossTS distribution. Start
        it by executing the OTS script. <!--What script?--> <interfacename>Current</interfacename> locates the factory
        in a manner specific to the ORB: using the name service, through
        <methodname>resolve_initial_references</methodname>, or via the <filename>CosServices.cfg</filename> file. The
        <filename>CosServices.cfg</filename> file is similar to <methodname>resolve_initial_references</methodname>, and
        is automatically updated when the transaction factory is started on a particular machine. Copy the file to each
        JBossTS instance which needs to share the same transaction factory.
      </para>
      <para>
        If you do not need subtransaction support, set the <varname>OTS_SUPPORT_SUBTRANSACTIONS</varname> property
        variable to <literal>NO</literal>.  The <methodname>setCheckedAction</methodname> method overrides the
        <interfacename>CheckedAction</interfacename> implementation associated with each transaction created by the
        thread.
      </para>
    </section>
  </section>

  <section>
    <title>Resource</title>
    <para>
      The Transaction Service uses a two-phase commit protocol to complete a top-level transaction with each registered
      resource.
    </para>
    <example>
      <title>Completing a top-level transaction</title>
      <programlisting role="JAVA" language="Java"><xi:include href="extras/completing_top_level_transaction.java" xmlns:xi="http://www.w3.org/2001/XInclude" parse="text" /></programlisting>
    </example>
    <para>
      The <interfacename>Resource</interfacename> interface defines the operations invoked by the transaction
      service. Each <interfacename>Resource</interfacename> object is implicitly associated with a single top-level
      transaction. Do not register a <interfacename>Resource</interfacename> with the same transaction more than
      once. When you tell a <interfacename>Resource</interfacename> to prepare, commit, or abort, it must do so on
      behalf of a specific transaction. However, the <interfacename>Resource</interfacename> methods do not specify the
      transaction identity. It is implicit, since a <interfacename>Resource</interfacename> can only be registered with
      a single transaction.
    </para>
    <para>
      Transactional objects must use the <methodname>register_resource</methodname> method to register objects
      supporting the <interfacename>Resource</interfacename> interface with the current transaction. An object
      supporting the <interfacename>Coordinator</interfacename> interface is either passed as a parameter in the case of
      explicit propagation, or retrieved using operations on the <interfacename>Current</interfacename> interface in the
      case of implicit propagation.  If the transaction is nested, the <interfacename>Resource</interfacename> is not
      informed of the subtransaction’s completion, and is registered with its parent upon commit.
    </para>
    <para>
      This example assumes that transactions are only nested two levels deep, for simplicity.
    </para>

    <figure>
      <title><interfacename>Resource</interfacename> and nested transactions</title>
      <mediaobject>
        <imageobject>
          <imagedata fileref="images/resource_nested_transactions.png" format="PNG"/>
        </imageobject>
        <textobject>
          <para>Resource interface and nested transactions</para>
        </textobject>
      </mediaobject>
    </figure>
    <para>
      Do not register a given <interfacename>Resource</interfacename> with the same transaction more than once, or it
      will receive multiple termination calls. When a <interfacename>Resource</interfacename> is directed to prepare,
      commit, or abort, it needs to link these actions to a specific transaction. Because
      <classname>Resource</classname> methods do not specify the transaction identity, but can only be associated with a
      single transaction, you can infer the identity.
    </para>
    <para>
      A single <interfacename>Resource</interfacename> or group of <interfacename>Resources</interfacename> guarantees
      the ACID properties for the recoverable object they represent. A Resource's work depends on the phase of its
      transaction.
    </para>
    <variablelist>
      <varlistentry>
        <term>prepare</term>
        <listitem>
          <para>
            If none of the persistent data associated with the resource is modified by the transaction, the Resource can
            return <systemitem>VoteReadOnly</systemitem> and forget about the transaction. It does not need to know the
            outcome of the second phase of the commit protocol, since it hasn't made any changes.
          </para>
          <para>
            If the resource can write, or has already written, all the data needed to commit the transaction to stable
            storage, as well as an indication that it has prepared the transaction, it can return
            <systemitem>VoteCommit</systemitem>. After receiving this response, the Transaction Service either commits
            or rolls back. To support recovery, the resource should store the
            <systemitem>RecoveryCoordinator</systemitem> reference in stable storage.
          </para>
          <para>
            The resource can return <systemitem>VoteRollback</systemitem> under any circumstances. After returning this
            response, the resource can forget the transaction.
          </para>
          <para>
            The <interfacename>Resource</interfacename> reports inconsistent outcomes using the
            <systemitem>HeuristicMixed</systemitem> and <systemitem>HeuristicHazard</systemitem> exceptions. One example
            is that a <interfacename>Resource</interfacename> reports that it can commit and later decides to roll
            back. Heuristic decisions must be made persistent and remembered by the
            <interfacename>Resource</interfacename> until the transaction coordinator issues the
            <methodname>forget</methodname> method. This method tells the <interfacename>Resource</interfacename> that
            the heuristic decision has been noted, and possibly resolved.
          </para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>rollback</term>
        <listitem>
          <para>
            The resource should undo any changes made as part of the transaction. Heuristic exceptions can be used to
            report heuristic decisions related to the resource. If a heuristic exception is raised, the resource must
            remember this outcome until the forget operation is performed so that it can return the same outcome in case
            rollback is performed again. Otherwise, the resource can forget the transaction.
          </para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>commit</term>
        <listitem>
          <para>
            If necessary, the resource should commit all changes made as part of this transaction. As with
            <methodname>rollback</methodname>, it can raise heuristic exceptions. The
            <systemitem>NotPrepared</systemitem> exception is raised if the resource has not been prepared.
          </para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>commit_one_phase</term>
        <listitem>
          <para>
            Since there can be only a single resource, the <systemitem>HeuristicHazard</systemitem> exception reports
            heuristic decisions related to that resource. <!-- Link to how to disable -->
          </para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>forget</term>
        <listitem>
          <para>
            Performed after the resource raises a heuristic exception. After the coordinator determines that the
            heuristic situation is addressed, it issues <methodname>forget</methodname> on the resource. The resource
            can forget all knowledge of the transaction.
          </para>
        </listitem>
      </varlistentry>
    </variablelist>
  </section>
  
  <section>
    <title>SubtransactionAwareResource</title>
    <para>
      Recoverable objects that need to participate within a nested transaction may support the
      <interfacename>SubtransactionAwareResource</interfacename> interface, a specialization of the
      <interfacename>Resource</interfacename> interface.
    </para>
    
    <example>
      <title>Interface <interfacename>SubtransactionAwareResource</interfacename></title>
      <programlisting role="JAVA" language="Java"><xi:include href="extras/SubtransactionAwareResource.java" xmlns:xi="http://www.w3.org/2001/XInclude" parse="text" /></programlisting>
    </example>
    <para>
      A recoverable object is only informed of the completion of a nested transaction if it registers a
      <interfacename>SubtransactionAwareResource</interfacename>. Register the object with either the
      <methodname>register_resource</methodname> of the <interfacename>Coordinator</interfacename> interface, or the
      <methodname>register_subtran_aware</methodname> method of the <interfacename>Current</interfacename> interface.  A
      recoverable object registers Resources to participate within the completion of top-level transactions, and
      SubtransactionAwareResources keep track of the completion of subtransactions. The
      <methodname>commit_subtransaction</methodname> method uses a reference to the parent transaction to allow
      subtransaction resources to register with these transactions.
    </para>
    <para>
      SubtransactionAwareResources find out about the completion of a transaction after it terminates. They cannot
      affect the outcome of the transaction. Different OTS implementations deal with exceptions raised by
      SubtransactionAwareResources in implementation-specific ways.
    </para>
    <para>
      Use method <methodname>register_resource</methodname> or method <methodname>register_subtran_aware</methodname> to
      register a SubtransactionAwareResource with a transaction using.
    </para>
    <variablelist>
      <varlistentry>
        <term>register_resource</term>
        <listitem>
          <para>
            If the transaction is a subtransaction, the resource is informed of its completion, and automatically
            registered with the subtransaction’s parent if the parent commits.
          </para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>register_subtran_aware</term>
        <listitem>
          <para>
            If the transaction is not a subtransaction, an exception is thrown. Otherwise, the resource is informed when
            the subtransaction completes. Unlike <methodname>register_resource</methodname>, the resource is not
            propagated to the subtransaction’s parent if the transaction commits. If you need this propagation,
            re-register using the supplied parent parameter.
          </para>
        </listitem>
      </varlistentry>
    </variablelist>
    <figure>
      <title>Method <methodname>register_subtran_aware</methodname></title>
      <mediaobject>
        <imageobject>
          <imagedata fileref="images/register_subtran_aware.png" format="PNG"/>
        </imageobject>
        <textobject>
          <para><methodname>register_subtran_aware</methodname></para>
        </textobject>
      </mediaobject>
    </figure>
    <figure>
      <title>Method <methodname>register_resource</methodname></title>
      <mediaobject>
        <imageobject>
          <imagedata fileref="images/register_resource.png" format="PNG"/>
        </imageobject>
        <textobject>
          <para><methodname>register_resource</methodname></para>
        </textobject>
      </mediaobject>
    </figure>
    <para>
      In either case, the resource cannot affect the outcome of the transaction completion. It can only act on the
      transaction's decision, after the decision is made. However, if the resource cannot respond appropriately, it can
      raise an exception. Thee OTS handles these exceptions in an implementation-specific way.
    </para>
    
    <section>
      <title>JBossTS specifics</title>
      <para>
        A <classname>SubtransactionAwareResource</classname> which raises an exception to the commitment of a
        transaction may create inconsistencies within the transaction if other
        <classname>SubtransactionAwareResources</classname> think the transaction committed. To prevent this possibility
        of inconsistency, JBossTS forces the enclosing transaction to abort if an exception is raised.
      </para>
      <para>
        JBossTS also provides extended subtransaction aware resources to overcome this, and other problems. See Section
        for further details.
      </para>
      
    </section>

  </section>
  
  <section>
    <title>The <interfacename>Synchronization</interfacename> interface</title>
    <para>
      If an object needs notification before a transaction commits, it can register an object which is an implements the
      <interfacename>Synchronization</interfacename> interface, using the
      <methodname>register_synchronization</methodname> operation of the <interfacename>Coordinator</interfacename>
      interface. Synchronizations flush volatile state data to a recoverable object or database before the transaction
      commits. You can only associate Synchronizations with top-level transactions. If you try to associate a
      Synchronization to a nested transaction, an exception is thrown. Each object supporting the
      <interfacename>Synchronization</interfacename> interface is associated with a single top-level transaction.
    </para>
    
    <example>
      <title>Synchronization</title>
      <programlisting role="JAVA" language="Java"><xi:include href="extras/synchronization.java" xmlns:xi="http://www.w3.org/2001/XInclude" parse="text" /></programlisting>
    </example>
    <para>
      The method <methodname>before_completion</methodname> is called before the two-phase commit protocol starts, and
      <methodname>after_completion</methodname> is called after the protocol completes. The final status of the
      transaction is given as a parameter to <methodname>after_completion</methodname>. If
      <methodname>before_completion</methodname> raises an exception, the transaction rolls back. Any exceptions thrown
      by <methodname>after_completion</methodname> do not affect the transaction outcome.
    </para>
    <para>
      The OTS only requires Synchronizations to be invoked if the transaction commits. If it rolls back, registered
      Synchronizations are not informed.
    </para>
    <para>
      Given the previous description of <interfacename>Control</interfacename>, <interfacename>Resource</interfacename>,
      <interfacename>SubtransactionAwareResource</interfacename>, and Synchronization, the following UML relationship
      diagram can be drawn:
    </para>
    <figure>
      <title>Relationship between Control, Resource, SubtransactionAwareResource, and Synchronization</title>
      <mediaobject>
        <imageobject>
          <imagedata fileref="images/interface_relationship.png" format="PNG"/>
        </imageobject>
        <textobject>
          <para>Relationship between Control, Resource, SubtransactionAwareResource, and Synchronization</para>
        </textobject>
      </mediaobject>
    </figure>

    
    <section>
      <title>JBossTS specifics</title>
      <para>
        Synchronizations must be called before the top-level transaction commit protocol starts, and after it
        completes. By default, if the transaction is instructed to roll back, the Synchronizations associated with the
        transaction is not contacted. To override this, and call Synchronizations regardless of the transaction's
        outcome, set the <varname>OTS_SUPPORT_ROLLBACK_SYNC</varname> property variable to <literal>YES</literal>.
      </para>
      <para>
        If you use distributed transactions and interposition, a local proxy for the top-level transaction coordinator
        is created for any recipient of the transaction context. The proxy looks like a <classname>Resource</classname>
        or <classname>SubtransactionAwareResource</classname>, and registers itself as such with the actual top-level
        transaction coordinator. The local recipient uses it to register <classname>Resources</classname> and
        <classname>Synchronizations</classname> locally.
      </para>
      <para>
        The local proxy can affect how Synchronizations are invoked during top-level transaction commit. Without the
        proxy, all Synchronizations are invoked before any Resource or SubtransactionAwareResource objects are
        processed. However, with interposition, only those Synchronizations registered locally to the transaction
        coordinator are called. Synchronizations registered with remote participants are only called when the interposed
        proxy is invoked. The local proxy may only be invoked after locally-registered Resource or
        SubtransactionAwareResource objects are invoked. With the
        <varname>OTS_SUPPORT_INTERPOSED_SYNCHRONIZATION</varname> property variable set to <literal>YES</literal>, all
        Synchronizations are invoked before any Resource or SubtransactionAwareResource, no matter where they are
        registered.
      </para>
    </section>
  </section>

  <section>
    <title>Transactions and registered resources</title>
    <figure>
      <title>Relationship between a transaction <interfacename>Control</interfacename> and the resources registered with
      it</title>
      <mediaobject>
        <imageobject>
          <imagedata fileref="images/control_and_resources.png" format="PNG"/>
        </imageobject>
        <textobject>
          <para>Relationship between a transaction <interfacename>Control</interfacename> and the resources registered
          with it</para>
        </textobject>
      </mediaobject>
    </figure>
    <para>
      In <xref linkend="subtransaction-commit" />, a subtransaction with both <classname>Resource</classname> and
      <classname>SubtransactionAwareResource</classname> objects commits.  The
      <classname>SubtransactionAwareResources</classname> were registered using
      <methodname>register_subtran_aware</methodname>. The <classname>Resources</classname> do not know the
      subtransaction terminated, but the <classname>SubtransactionAwareResources</classname> do. Only the
      <classname>Resources</classname> are automatically propagated to the parent transaction.
    </para>
    <figure id="subtransaction-commit">
      <title>Subtransaction commit</title>
      <mediaobject>
        <imageobject>
          <imagedata fileref="images/subtransaction-commit.png" format="PNG"/>
        </imageobject>
        <textobject>
          <para>Subtransaction commit</para>
        </textobject>
      </mediaobject>
    </figure>
    <para>
      <xref linkend="subtransaction-rollback" /> illustrates the impact of a subtransaction rolling back. Any registered
      resources are discarded, and all <classname>SubtransactionAwareResources</classname> are informed of the
      transaction outcome.
    </para>
    <figure id="subtransaction-rollback">
      <title>Subtransaction rollback</title>
      <mediaobject>
        <imageobject>
          <imagedata fileref="images/subtransaction-rollback.png" format="PNG"/>
        </imageobject>
        <textobject>
          <para>Subtransaction rollback</para>
        </textobject>
      </mediaobject>
    </figure>
    <para>
      <xref linkend="top-level-commit" /> shows the activity diagram for committing a top-level
      transaction. Subtransactions within the top-level transaction which have also successfully committed propagate
      <classname>SubtransactionAwareResources</classname> to the top-level transaction. These
      <classname>SubtransactionAwareResources</classname> then participate within the two-phase commit protocol. Any
      registered <classname>Synchronizations</classname> are contacted before <methodname>prepare</methodname> is
      called. Because of indirect context management, when the transaction commits, the transaction service changes the
      invoking thread’s transaction context.
    </para>
    <figure id="top-level-commit">
      <title>Top-level commit</title>
      <mediaobject>
        <imageobject>
          <imagedata fileref="images/top-level-commit.png" format="PNG"/>
        </imageobject>
        <textobject>
          <para>Top-level commit</para>
        </textobject>
      </mediaobject>
    </figure>
    <figure>
      <title>Top-level rollback</title>
      <mediaobject>
        <imageobject>
          <imagedata fileref="images/top-level-rollback.png" format="PNG"/>
        </imageobject>
        <textobject>
          <para>Top-level rollback</para>
        </textobject>
      </mediaobject>
    </figure>

  </section>

  <section>
    <title>The <interfacename>TransactionalObject</interfacename> interface</title>
    <para>
      The <interfacename>TransactionalObject</interfacename> interface indicates to an object that it is
      transactional. By supporting this interface, an object indicates that it wants to associate the transaction
      context associated with the client thread with all operations on its interface. The
      <interfacename>TransactionalObject</interfacename> interface defines no operations.
    </para>
    <para>
      OTS specifications do not require an OTS to initialize the transaction context of every request handler. It is
      only a requirement if the interface supported by the target object is derived from
      <interfacename>TransactionalObject</interfacename>. Otherwise, the initial transaction context of the thread is
      undefined. A transaction service implementation can raise the <systemitem>TRANSACTION_REQUIRED</systemitem>
      exception if a <classname>TransactionalObject</classname> is invoked outside the scope of a transaction.
    </para>
    <para>
      In a single-address space application, transaction contexts are implicitly shared between clients and objects,
      regardless of whether or not the objects support the <interfacename>TransactionalObject</interfacename>
      interface. To preserve distribution transparency, where implicit transaction propagation is supported, you can
      direct JBossTS to always propagate transaction contexts to objects. The default is only to propagate if the object
      is a <interfacename>TransactionalObject</interfacename>. Set the <varname>OTS_ALWAYS_PROPAGATE_CONTEXT</varname>
      property variable to <literal>NO</literal> to override this behavior.
    </para>
    <para>
      By default, JBossTS does not require objects which support the <interfacename>TransactionalObject</interfacename>
      interface to invoked within the scope of a transaction. The object determines whether it should be invoked within
      a transaction. If so, it must throw the <systemitem>TransactionRequired</systemitem> exception. Override this
      default by setting the <varname>OTS_NEED_TRAN_CONTEXT</varname> shell environment variable to
      <literal>YES</literal>.
    </para>
    <important>
      <para>
        Make sure that the settings for <varname>OTS_ALWAYS_PROPAGATE_CONTEXT</varname> and
        <varname>OTS_NEED_TRAN_CONTEXT</varname> are identical at the client and the server. If they are not identical
        at both ends, your application may terminate abnormally.
      </para>
    </important>
    <!-- Removed because the content is already covered just above <section> <title>JBossTS specifics</title> <para> In
         a single-address space application (i.e., all objects reside within the same process), transaction contexts are
         implicitly shared between “clients” and objects, regardless of whether or not the objects support the
         TransactionalObject interface. Therefore, in order to preserve distribution transparency, where implicit
         transaction propagation is supported JBossTS will always propagate transaction contexts to objects. The default
         can be overridden by setting the environment variable OTS_ALWAYS_PROPAGATE_CONTEXT to NO.  </para> <para> By
         default, JBossTS does not require that objects supporting the TransactionalObject interface are invoked within
         the scope of a transaction. Rather, this it is left up to the object to determine whether it should be invoked
         within a transaction; if so, it should throw the TransactionRequired exception. This can be overridden by
         setting the OTS_NEED_TRAN_CONTEXT shell environment variable to YES.  </para> </section>
    -->
  </section>
  
  <section>
    <title>Interposition</title>
    <para>
      OTS objects supporting interfaces such as the <interfacename>Control</interfacename> interface are standard CORBA
      objects. When an interface is passed as a parameter in an operation call to a remote server, only an object
      reference is passed. This ensures that any operations that the remote server performs on the interface are
      correctly performed on the real object. However, this can have substantial penalties for the application, because
      of the overhead of remote invocation. For example, when the server registers a <classname>Resource</classname>
      with the current transaction, the invocation might be remote to the originator of the transaction.
    </para>
    <para>
      To avoid this overhead, your OTS may support interposition. This permits a server to create a local control object
      which acts as a local coordinator, and fields registration requests that would normally be passed back to the
      originator. This coordinator must register itself with the original coordinator, so that it can correctly
      participate in the commit protocol. Interposed coordinators form a tree structure with their parent coordinators.
    </para>
    <para>
      To use interposition, ensure that JBossTS is correctly initialized before creating objects. Also, the client and
      server must both use interposition. Your ORB must support filters or interceptors, or the
      <interfacename>CosTSPortability</interfacename> interface, since interposition requires the use of implicit
      transaction propagation. To use interposition, set the <varname>OTS_CONTEXT_PROP_MODE</varname> property variable
      to <literal>INTERPOSITION</literal>.
    </para>
    <note>
      <para>
        Interposition is not required if you use the JBossTS advanced API.
      </para>
    </note>
  </section>
  
  <section>
    <title>RecoveryCoordinator</title>
    <para>
      A reference to a <classname>RecoveryCoordinator</classname> is returned as a result of successfully calling
      <methodname>register_resource</methodname> on the transaction's <classname>Coordinator</classname>. Each
      <classname>RecoveryCoordinator</classname> is implicitly associated with a single
      <classname>Resource</classname>. It can drive the <classname>Resource</classname> through recovery procedures in
      the event of a failure which occurs during the transaction.
    </para>
    <figure>
      <title><interfacename>Resource</interfacename> and <interfacename>RecoveryCoordinator</interfacename></title>
      <mediaobject>
        <imageobject>
          <imagedata fileref="images/resource-and-recoverycoordinator.png" format="PNG"/>
        </imageobject>
        <textobject>
          <para>Resource and RecoveryCoordinator</para>
        </textobject>
      </mediaobject>
    </figure>
  </section>

  <section>
    <title>Checked transaction behavior</title>
    <para>
      The OTS supports both checked and unchecked transaction behavior.
    </para>
    <itemizedlist>
      <title>Integrity constraints of checked transactions</title>
      <listitem>
        <para>
          A transaction will not commit until all transactional objects involved in the transaction have completed their
          transactional requests.
        </para>
      </listitem>
      <listitem>
        <para>
          Only the transaction originator can commit the transaction
        </para>
      </listitem>
    </itemizedlist>
    <para>
      Checked transactional behavior is typical transaction behavior, and is widely implemented. Checked behavior
      requires implicit propagation, because explicit propagation prevents the OTS from tracking which objects are
      involved in the transaction.
    </para>
    <para>
      Unchecked behavior allows you to implement relaxed models of atomicity. Any use of explicit propagation implies
      the possibility of unchecked behavior, since you as the programmer are in control of the behavior. Even if you use
      implicit propagation, a server may unilaterally abort or commit the transaction using the
      <interfacename>Current</interfacename> interface, causing unchecked behavior.
    </para>
    <para>
      Some OTS implementations enforce checked behavior for the transactions they support, to provide an extra level of
      transaction integrity. The checks ensure that all transactional requests made by the application complete their
      processing before the transaction is committed. A checked Transaction Service guarantees that commit fails unless
      all transactional objects involved in the transaction complete the processing of their transactional
      requests. Rolling back the transaction does not require such as check, since all outstanding transactional
      activities will eventually roll back if they are not directed to commit.
    </para>
    <para>
      There are many possible implementations of checking in a Transaction Service. One provides equivalent function to
      that provided by the request and response inter-process communication models defined by X/Open. The X/Open
      Transaction Service model of checking widely implemented. It describes the transaction integrity guarantees
      provided by many existing transaction systems. These transaction systems provide the same level of transaction
      integrity for object-based applications, by providing a Transaction Service interface that implements the X/Open
      checks.  </para><!-- I do not understand this stuff at all -->
    <para>
      In X/Open, completion of the processing of a request means that the object has completed execution of its method
      and replied to the request. The level of transaction integrity provided by a Transaction Service implementing the
      X/Open model provides equivalent function to that provided by the XATMI and TxRPC interfaces defined by X/Open for
      transactional applications. X/Open DTP Transaction Managers are examples of transaction management functions that
      implement checked transaction behavior.  </para><!-- I do not understand this stuff at all -->
    <para>
      This implementation of checked behavior depends on implicit transaction propagation. When implicit propagation is
      used, the objects involved in a transaction at any given time form a tree, called the request tree for the
      transaction. The beginner of the transaction is the root of the tree. Requests add nodes to the tree, and replies
      remove the replying node from the tree. Synchronous requests, or the checks described below for deferred
      synchronous requests, ensure that the tree collapses to a single node before commit is issued.
    </para>
    <para>
      If a transaction uses explicit propagation, the Transaction Service has no way to know which objects are or will
      be involved in the transaction. Therefore, the use of explicit propagation is not permitted by a Transaction
      Service implementation that enforces X/Open-style checked behavior.
    </para>
    <para>
      Applications that use synchronous requests exhibit checked behavior. If your application uses deferred synchronous
      requests, all clients and objects need to be under the control of a checking Transaction Service. In that case,
      the Transaction Service can enforce checked behavior, by applying a <systemitem>reply</systemitem> check and a
      <systemitem>committed</systemitem> check. The Transaction Service must also apply a
      <systemitem>resume</systemitem> check, so that the transaction is only resumed by applications in the correct part
      of the request tree.
    </para>
    <informaltable>
      <tgroup cols="2">
        <colspec colwidth="150px"/>
        <colspec colwidth="290px"/>
        <tbody>
          <row>
            <entry>reply check</entry>
            <entry>
              <para>
                Before an object replies to a transactional request, a check is made to ensure that the object has
                received replies to all the deferred synchronous requests that propagated the transaction in the
                original request. If this condition is not met, an exception is raised and the transaction is marked as
                rollback-only. A Transaction Service may check that a reply is issued within the context of the
                transaction associated with the request.
              </para>
            </entry>
          </row>
          <row>
            <entry>commit check</entry>
            <entry>
              <para>
                Before a commit can proceed, a check is made to ensure that the commit request for the transaction is
                being issued from the same execution environment that created the transaction, and that the client
                issuing commit has received replies to all the deferred synchronous requests it made that propagated the
                transaction.
              </para>
            </entry>
          </row>
          <row>
            <entry>resume check</entry>
            <entry>
              <para>
                Before a client or object associates a transaction context with its thread of control, a check is made
                to ensure that this transaction context was previously associated with the execution environment of the
                thread. This association would exist if the thread either created the transaction or received it in a
                transactional operation.
              </para>
            </entry>
          </row>
        </tbody>
      </tgroup>
    </informaltable>
    <section>
      <title>JBossTS specifics</title>
      <para>
        Where support from the ORB is available, JBossTS supports X/Open checked transaction behavior. However, unless
        the <varname>OTS_CHECKED_TRANSACTIONS</varname> property variable is set to <literal>YES</literal>, checked
        transactions are disabled. This is the default setting.
      </para>
      <note>
        <para>
          Checked transactions are only possible with a co-located transaction manager.
        </para>
      </note>
      <para>
        In a multi-threaded application, multiple threads may be associated with a transaction during its lifetime,
        sharing the context. In addition, if one thread terminates a transaction, other threads may still be active
        within it. In a distributed environment, it can be difficult to guarantee that all threads have finished with a
        transaction when it terminates. By default, JBossTS issues a warning if a thread terminates a transaction when
        other threads are still active within it, but allow the transaction termination to continue. You can choose to
        block the thread which is terminating the transaction until all other threads have disassociated themselves from
        its context, or use other methods to solve the problem. JBossTS provides the
        <classname>com.arjuna.ats.arjuna.coordinator.CheckedAction</classname> class, which allows you to override the
        thread and transaction termination policy. Each transaction has an instance of this class associated with it,
        and you can implement the class on a per-transaction basis.
      </para>
      
      <example>
        <title><classname>CheckedAction</classname> implementation</title>
        <programlisting role="JAVA" language="Java"><xi:include href="extras/CheckedAction-implementation.java" xmlns:xi="http://www.w3.org/2001/XInclude" parse="text" /></programlisting>
      </example>
      <para>
        When a thread attempts to terminate the transaction and there active threads exist within it, the system invokes
        the <methodname>check</methodname> method on the transaction’s <classname>CheckedAction</classname> object. The
        parameters to the check method are:
      </para>
      <informaltable>
        <tgroup cols="2">
          <colspec colwidth="150px"/>
          <colspec colwidth="290px"/>
          <tbody>
            <row>
              <entry>isCommit</entry>
              <entry>
                <para>
                  Indicates whether the transaction is in the process of committing or rolling back.
                </para>
              </entry>
            </row>
            <row>
              <entry>actUid</entry>
              <entry>
                <para>
                  The transaction identifier.
                </para>
              </entry>
            </row>
            <row>
              <entry>list</entry>
              <entry>
                <para>
                  A list of all of the threads currently marked as active within this transaction.
                </para>
              </entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>
      <para>
        When <methodname>check</methodname> returns, the transaction termination continues. Obviously the state of the
        transaction at this point may be different from that when check was called.
      </para>
      <para>
        Set the <classname>CheckedAction</classname> instance associated with a given transaction with the
        <methodname>setCheckedAction</methodname> method of <interfacename>Current</interfacename>.
      </para>
    </section>
  </section>

  <section>
    <title>Summary of JBossTS implementation decisions</title>
    <itemizedlist>
      <listitem>
        <para>
          Any execution environment (thread, process) can use a transaction Control.
        </para>
      </listitem>
      <listitem>
        <para>
          <interfacename>Control</interfacename>s, <interfacename>Coordinator</interfacename>s, and
          <interfacename>Terminator</interfacename>s are valid for use for the duration of the transaction if implicit
          transaction control is used, via <interfacename>Current</interfacename>. If you use explicit control, via the
          <classname>TransactionFactory</classname> and <classname>Terminator</classname>, then use the
          <methodname>destroyControl</methodname> method of the OTS class in
          <classname>com.arjuna.CosTransactions</classname> to signal when the information can be garbage collected.
        </para>
      </listitem>
      <listitem>
        <para>
          You can propagate <interface>Coordinator</interface>s and <interfacename>Terminator</interfacename>s between
          execution environments.
        </para>
      </listitem>
      <listitem>
        <para>
          If you try to commit a transaction when there are still active subtransactions within it, JBossTS rolls back
          the parent and the subtransactions.
        </para>
      </listitem>
      <listitem>
        <para>
          JBossTS includes full support for nested transactions. However, if a resource raises an exception to the
          commitment of a subtransaction after other resources have previously been told that the transaction committed,
          JBossTS forces the enclosing transaction to abort. This guarantees that all resources used within the
          subtransaction are returned to a consistent state. You can disable support for subtransactions by setting the
          <varname>OTS_SUPPORT_SUBTRANSACTIONS</varname> variable to <literal>NO</literal>.
        </para>
      </listitem>
      <listitem>
        <para>
          Obtain <interfacename>Current</interfacename> from the <methodname>get_current</methodname> method of the OTS.
        </para>
      </listitem>
      <listitem>
        <para>
          A timeout value of zero seconds is assumed for a transaction if none is specified using
          <methodname>set_timeout</methodname>.
        </para>
      </listitem>
      <listitem>
        <para>
          by default, <interfacename>Current</interfacename> does not use a separate transaction manager server by
          default. Override this behavior by setting the <varname>OTS_TRANSACTION_MANAGER</varname> environment
          variable. Location of the transaction manager is ORB-specific.
        </para>
      </listitem>
      <listitem>
        <para>
          Checked transactions are disabled by default. To enable them, set the
          <varname>OTS_CHECKED_TRANSACTIONS</varname> property to <literal>YES</literal>.
        </para>
      </listitem>
    </itemizedlist>
  </section>
</chapter>
