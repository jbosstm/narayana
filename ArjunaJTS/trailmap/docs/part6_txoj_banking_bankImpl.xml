<?xml version="1.0"?>
<!--
  JBoss, Home of Professional Open Source
  Copyright 2006, Red Hat Middleware LLC, and individual contributors
  as indicated by the @author tags. 
  See the copyright.txt in the distribution for a full listing 
  of individual contributors.
  This copyrighted material is made available to anyone wishing to use,
  modify, copy, or redistribute it subject to the terms and conditions
  of the GNU Lesser General Public License, v. 2.1.
  This program is distributed in the hope that it will be useful, but WITHOUT A
  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
  PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details.
  You should have received a copy of the GNU Lesser General Public License,
  v.2.1 along with this distribution; if not, write to the Free Software
  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
  MA  02110-1301, USA.

  
  (C) 2005-2006,
  @author JBoss Inc.
-->
<page title="Arjuna Technologies Limited: Trail map: Running and Testing Examples" rootpath="../..">
	<header>         Implementing the Account interface  </header>
	<content>
		<navigation>
			<links include="includes/www_arjuna_com_navigation.xml"/>
			<links include="includes/trailmap_navigation.xml"/>
			<links title="Navigation">
				<link ref="index.html">Home</link>
				<link ref="part6_txoj_banking_develop.html">Previous</link>
			</links>
			<links include="includes/trailmap_additional.xml"/>
		</navigation>
		<area title="Implementing the Bank interface">
			<html>
				<p>To take benefit from the persistency and locking mechanism provided by ArjunaCore, 
  a user class can inherit from the appropriate class (StateManager for recovery, 
  and LockManager for recovery and concurrency control). The BankImpl class that 
  implements the Bank interface inherits the LockManager and implements the BankOperations 
  interface generated by the CORBA IDL compiler. Since multiple inheritance is 
  not allowed in Java, inheriting the BankPOA class, as made in simple jts remote 
  version, in addition to the LockManager is not possible. That we use in this 
  version a CORBA TIE mechanism to associate a servant to an CORBA object reference.</p>
				<p>The Java interface definition of the BankImpl class is given below:</p>
				<pre>public class BankImpl extends LockManager implements BankOperations
{
  public BankImpl(OA oa);
  public BankImpl(Uid uid, OA oa);
  public BankImpl(Uid uid);
  public Account create_account( String name );
  public Account get_account( String name );
  public boolean save_state (OutputObjectState os, int ObjectType);
  public boolean restore_state (InputObjectState os, int ObjectType);
  public String type();

  public static final int ACCOUNT_SIZE = 10; 
  // ACCOUNT_SIZE is the maximum number of accounts 
  private String [] accounts;
  private int numberOfAccounts;
  private ORB _orb;
  private OA _oa;
  private java.util.Hashtable _accounts; //The list of accounts 

}</pre>
				<ul>
					<li>Constructors and Destructor 
  <p>To use an existing persistent object requires the use of a special constructor 
      that is required to take the Uid of the persistent object; the implementation 
      of such a constructor is given below:</p>

<pre>public BankImpl(Uid uid)
{
  super(uid);
  _accounts = new java.util.Hashtable();
  numberOfAccounts = 0;
  accounts = new String[ACCOUNT_SIZE];
}</pre>
<p>The following constructor is invoked during the first creation of the Bank Object.</p>
<pre>
public BankImpl(OA oa)
{ super(ObjectType.ANDPERSISTENT);
  _accounts = new java.util.Hashtable();
  _oa = oa;<br/>  numberOfAccounts = 0;
  accounts = new String[ACCOUNT_SIZE];
}</pre>
<p>The following constructor is invoked on successive BankServer restart. 
    A bank already exists and should be recreated. Invoking super or the constructor 
    of the inherited class leads to execute the restore_state method, described 
    below, of the BankImpl class to rebuild the list of accounts previously 
    created, if any.</p>
<pre>
public BankImpl(Uid uid, OA oa)
{ super(uid);
  _accounts = new java.util.Hashtable();
  _oa = oa;
  numberOfAccounts = 0;
  accounts = new String[ACCOUNT_SIZE];
}
</pre>

	<p>The destructor of the queue class is only required to call the terminate operation of LockManager.</p>
		</li>
	</ul>
<blocquote>
<pre>public void finalize ()
{
  super.terminate();
}
</pre>
</blocquote>
<ul>
	<li>account management operations 

<pre>public Account create_account( String name )
{
  AccountImpl acc;
  AccountPOA account = null;
  //Attempt to obtain the lock for change
  if (setlock(new Lock(LockMode.WRITE), 0) == LockResult.GRANTED)
   {
     //Check if the maximum number of accounts is not reached
     if (numberOfAccounts &lt; ACCOUNT_SIZE) 
     {
     acc = new AccountImpl(name); //Create a new account
     //Use the TIE mechanism to create a CORBA object
      account = new AccountPOATie(acc); 
      //Add the account to the list of accounts that 
      //facilitate to retrieve accounts
      _accounts.put( name, acc);  
       //The Uid of the created account is put in the array
       accounts[numberOfAccounts] = acc.get_uid().toString();
       numberOfAccounts++; 
     }
  }
  return com.arjuna.demo.jts.txojbank.
       AccountHelper.narrow(_oa.corbaReference(account));
}

public Account get_account(String name)
  throws NotExistingAccount
{
  // Only the hashtable list is used to retrieve the account
  AccountImpl acc = ( AccountImpl ) _accounts.get( name );
  AccountPOA account = new AccountPOATie(acc);
  if ( acc == null )
     throw new NotExistingAccount(&quot;The Account 
        requested does not exist&quot;);
  return com.arjuna.demo.jts.txojbank.
    AccountHelper.narrow(_oa.corbaReference(account));	
}</pre>

			</li>
		</ul>
 <ul>
	<li>save_state, restore_state and type 

<pre>public boolean save_state (OutputObjectState os, int ObjectType)
{
   if (!super.save_state(os, ObjectType))
     return false;
   
   try
   {
     os.packInt(numberOfAccounts);
     if (numberOfAccounts &gt; 0)
     {
      // All Uid located in the array will be saved
      for (int i = 0; i &lt; numberOfAccounts; i++)
        os.packString(accounts[i]); 
     }
     return true;
   }
   catch (Exception e)
   {
     return false;
   }
}</pre>
<pre>public boolean restore_state (InputObjectState os, int ObjectType)
{
   if (!super.restore_state(os, ObjectType))
   {
     return false;
   }
   try
   {
      numberOfAccounts = os.unpackInt();
   
      if (numberOfAccounts &gt; 0)
      {
        for (int i = 0; i &lt; numberOfAccounts; i++) 
        {
          accounts[i] = os.unpackString();
          //each stored Uid is re-used to recreate 
          //a stored account object
          AccountImpl acc = new AccountImpl(new Uid(accounts[i]));
          acc.activate(); 
          //Once recreated the account object 
          //is activated and added to the list.
         _accounts.put( acc.getName(), acc);
        }
      }
      return true;
   }
   catch (Exception e)
   {
      return false;
   }
} </pre>
<pre>public String type ()
{
   return &quot;/StateManager/LockManager/BankServer&quot;;
}</pre>

					</li>
				</ul>
				<h5>Sample Application Source Code</h5>
				<p>Full source code for the <a class="linkscoloured" href="../src/com/arjuna/demo/jts/txojbank/BankImpl.java">BankImpl</a> 
  class is included to provide you with a starting point for experimentation.<br/>
				</p>
			</html>
		</area>
	</content>
	<footer/>
</page>
