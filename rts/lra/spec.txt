* changes to the protocol *
1) when starting a new LRA tell the coordinator if it is nested using a query param: ?ParentLRA=<id>
   (or just check if there a pre existing LRA when a new one is started)
2) if POST to the compensator url is successful it will optionally return application specific
   data about the outcome. Closing or cancellng an LRA will produce multiple data items, the
   implementation can return these as a list or as a map keyed by either the LRA url or by the
   compensator url (the later is preferable).
3) (WARN clashes with "GET on /lra-coordinator/active and /lra-coordinator/recovery ..."
 so change spec to /jfdi-coordinator/status/<TxId> instead
The requested resource is no longer available at the server and no forwarding address is known.
4) Added Precondition Failed


The JFDI transaction protocol is a forward-compensation based approach. It does not assume that resources are locked for the duration of the transaction. (Much of this model was subsequently incorporated into WS-LRA or WS-BP.

Communication is initiated by the client in the form of HTTP GET, DELETE, POST, and PUT requests. GET is used to read data, DELETE is used to delete data, POST is used to create new data, and PUT is used to modify existing data. The server responds to requests by returning status codes, data, or both. Because REST transactions are stateless, each HTTP request must be accompanied by a URI that uniquely identifies the specific resource being requested. In addition to a URI, POST and PUT requests must be accompanied by an XML document containing data that conforms to the schema.

Different HTTP status codes (and data) are returned by the server in response to requests:

GET
A successful GET returns status code 200 (OK) and XML data in the body.
PUT
A successful PUT returns status code 200 (OK) and XML data in the body.
POST
A successful POST returns status code 201 (created) and a Location header containing the URI of the newly created resource.
DELETE
A successful DELETE returns status code 204 only (no data).

Error status codes include:

400: Bad request
The request could not be understood by the server due to malformed syntax.
401: Unauthorized
Invalid username and/or password, or insufficient privileges for the command.
404: Not found
Couldn't find the resource specified by the URI.
410: Gone
The requested resource is no longer available at the server and no forwarding address is known.
412 Precondition Failed
The request is not valid for the current protocol state (eg trying to join or leave an LRA that is closing)

Although POST is "unsafe" and we should use PUT because it is idempotent, it's not well supported by browsers.

The long running action model (jfdi) is designed specifically for those business interactions that occur over a long duration. Within this model, an activity reflects business interactions: all work performed within the scope of an activity is required to be compensatable. Therefore, an activity’s work is either performed successfully or undone. How services perform their work and ensure it can be undone if compensation is required, are implementation choices and not exposed to the jfdi model. The jfdi model simply defines the triggers for compensation actions and the conditions under which those triggers are executed.

As with most transaction models, jfdi is concerned only with ensuring participants obey the protocol necessary to make an activity compensatable; semantics of the business interactions are not part of jfdi model. Issues such as isolation of services between potentially conflicting activities and durability of service work are assumed to be implementation decisions. The coordination protocol used to ensure an activity is completed successfully or compensated is not two-phase and is intended to better model business-to-business interactions. Although this may result in non-atomic behaviour for the overall business activity, other activities may be started by the application or service to attempt to compensate in some other manner.
Each jfdi is tied to the scope of an activity. This means that when the activity terminates, the jfdi coordination protocol will be automatically performed either to accept or compensate the work.

In the jfdi model, each activity is bound to the scope of a compensation interaction. For example, when a user reserves a seat on a flight, the airline reservation centre may take an optimistic approach and actually book the seat and debit the users account, relying on the fact that most of their customers who reserve seats later book them; the compensation action for this activity would obviously be to un-book the seat and credit the user’s account. Work performed within the scope of a nested jfdi must remain compensatable until an enclosing activity informs the service(s) that it is no longer required. For example, consider the night-out reservation example mentioned earlier.

As in any business interaction, application services may or may not be compensatable. Even the ability to compensate may be a transient capability of a service. A Compensator is the jfdi participant that operates on behalf of a service to undo the work it performs within the scope of an jfdi or to compensate for the fact that the original work could not be completed. How compensation is carried out will obviously be dependant upon the service; compensation work may be carried out by other jfdis which themselves have Compensators.

Because jfdis may execute over a long period of time, compensation may have to occur at any time and be tolerant of failures. Consequently, Compensators may have to maintain information within a durable form

When a service does work that may have to be later compensated within the scope of an jfdi, it enlists a Compensator participant with the jfdi coordinator. The Compensator will be invoked in the following way by the jfdi coordinator when the activity terminates:
•       Success: the activity has completed successfully. If the activity is nested then Compensators may propagate themselves (or new Compensators) to the enclosing jfdi. Otherwise the Compensators are informed that the activity has terminated and they can perform any necessary cleanups.
•       Fail: the activity has completed unsuccessfully. All Compensators that are registered with the jfdi will be invoked to perform compensation in the reverse order. The coordinator forgets about all Compensators that indicated they operated correctly. Otherwise, compensation may be attempted again (possibly after a period of time) or alternatively a compensation violation has occurred and must be logged.

Each service is required to log sufficient information in order to ensure (with best effort) that compensation is possible. Each compensator (participant) or subordinate coordinator is responsible for ensuring that sufficient data is made durable in order to undo the jfdi in the event of failures. Interposition and check pointing of state allow the system to drive a consistent view of the outcome and recovery actions taken, but allowing always the possibility that recovery isn’t possible and must be logged or flagged for the administrator. In a large scale environment or in the presence of long term failures, recovery may not be automatic. As such, manual intervention may be necessary to restore an application’s consistency.

Obviously jfdis may be used sequentially and concurrently, where the termination of a jfdi signals the start of some other unit of work within an application. However, jfdis are units of compensatable work and an application may have as many such units of work operating simultaneously as it needs to accomplish its tasks. Furthermore, the outcome of work within jfdis may determine how other jfdis are terminated. An application can be structured to so that jfdis are used to assemble units of compensatable work and then held in the active state while the application performs other work in the scope of different (concurrent or sequential) jfdis. Only when the right subset of work (jfdis) is arrived at by the application will that subset be confirmed; all other jfdis will be told to cancel (complete in a failure state).

The jfdi transaction coordinator URL is:

http://<machine>/jfdi-coordinator

Performing a GET on that URL returns a list of all transactions know to the coordinator (active and recovery).

Performing a GET on /jfdi-coordinator/recovery returns a list of transactions that are in recovery.

Performing a GET on /jfdi-coordinator/active returns a list of inflight transaction ids, which can the be used below.

Performing a DELETE on any of the jfdi-coordinator URLs will return a 401.

Each client is expected to have a unique identity. We'll call that ClientID, which can be a URL too.

Performing a POST on jfdi-coordinator/start?<ClientID> will start a new jfdi with a default timeout and return a URL of the form <machine>/jfdi-coordinator/<id>
Performing a POST on jfdi-coordinator/start?<ClientID>#timeout will start a new transaction with the specified timeout and return a URL of the form <machine>/jfdi-coordinator/<id>

*Addition: Nested transactions can be started by passing the id of the parent LRA as a query parameter:
  ?ParentLRA=<id of parent LRA>

If the transaction is terminated because of a timeout, the /jfdi-coordinator/<id> URL is deleted. All further invocations on the URL will return 404. The invoker can assume this was equivalent to a compensate operation.

The jfdi model uses a presumed nothing protocol: the coordinator must communicate with Compensators in order to inform them of the jfdi activity. Every time a Compensator is enrolled with a jfdi, the coordinator must make information about it durable so that the Compensator can be contacted when the jfdi terminates, even in the event of subsequent failures. Compensators, clients and coordinators cannot make any presumption about the state of the global transaction without consulting the coordinator and all compensators, respectively.

Performing a GET on /jfdi-coordinator/<TxId> returns 200 if the transaction is still active.
(WARN clashes with "GET on /jfdi-coordinator/active  and /jfdi-coordinator/recovery ..."
 so change spec to /jfdi-coordinator/status/<TxId> instead

Once the transaction terminates it is up to the implementation to retain information about the transaction for an indeterminate amount of time.

Performing a GET on /jfdi-coordinator/completed/<TxId> returns 200 if the transaction completed successfully. 404 means it is not present.

Performing a GET on /jfdi-coordinator/compensated/<TxId> returns 200 if the transaction compensated. 404 means it is not present.

Performing a PUT on /jfdi-coordinator/<id>/close will trigger the successful completion of the transaction and all compensators will be dropped by the coordinator (the complete message will be sent to the compensators). Upon termination, the URL is implicitly deleted. If it no longer exists, then 404 will be returned. The invoker cannot know for sure whether the transaction completed or compensated without enlisting a participant.

Each transaction is also uniquely identified.

When a compensator registers with a transaction we need to return a unique handle (aka RecoveryCoordinator) so that it can be uniquely reasoned about later. So we use PUT:

Performing a PUT on /jfdi-coordinator/<TxId> with the URL of the compensator (see below), will register the compensator in the transaction and also return a unique resource reference for that compensator:

http://<machine>/jfdi-recovery-coordinator/<RecCoordId>

Performing a GET on that URL will return the original compensator URL.
Performing a PUT on that URL will overwrite the old compensator URL with the new one supplied.

Performing a DELETE or POST will return a 401.

When making an invocation on a resource that needs to participate in a transaction, the transaction context (URL) needs to be transmitted to the resource. How this happens is outside the scope of this effort. It may occur as additional payload on the initial request, or it may be that the client sends the context out-of-band to the resource.

Once a resource has the transaction URL, it can register participation in the transaction (enlist the compensator). The compensator is free to use whatever URL structure it desires for uniquely identifying itself. The compensator URL must be unique for the transaction as well: the same compensator cannot be involved in more than one transaction. The compensator must support the following operations:

Performing a GET on the participant URL will return the current status of the compensator, or 404 if the compensator is no longer present.

The following types are returned by Compensators to indicate the current status:
•       Compensating: the Compensator is currently compensating for the jfdi.
•       Compensated: the Compensator has successfully compensated for the jfdi.
•       FailedToCompensate: the Compensator was not able to compensate for the jfdi. It must maintain information about the work it was to compensate until the coordinator sends it a forget message.
•       Completing: the Compensator is tidying up after being told to complete.
•       Completed: the coordinator/participant has confirmed.
•       FailedToComplete: the Compensator was unable to tidy-up.

Performing a POST on <URL>/compensate will cause the participant to compensate the work that was done within the scope of the transaction. Performing a POST on <URL>/complete will cause the participant to tidy up and it can forget this transaction. In either case the compensator will either return a 200 OK code or a URL which indicates the outcome. That URL can be probed (via GET) and will simply return the same (implicit) information:

<URL>/cannot-compensate
<URL>/cannot-complete

If the compensator is unknown (the URL is invalid) then 410 will be returned. It can be assumed by the coordinator that the service compensated.

Note, a Compensator that cannot compensate must maintain its information until it is told to forget via POST <URL>/forget

Performing a GET on <URL>/compensate will return 400.

Performing a PUT on <URL>/compensate will return 400.

It is expected that the receipt of cannot-compensate or cannot-complete will be handled by the application or logged if not.

Note, a Compensator can resign from the jfdi at any time prior to the completion of an activity by performing a PUT on /jfdi-coordinator/<TxId>/remove with the URL of the compensator.

When a Compensator is enrolled with an jfdi, the entity performing the enrol can supply a number of qualifiers which may be used by the coordinator and business application to influence the overall outcome of the activity. The currently supported qualifiers are:
•       TimeLimit: the time limit (in seconds) that the Compensator can guarantee that it can compensate the work performed by the service. After this time period has elapsed, it may no longer be possible to undo the work within the scope of this (or any enclosing) jfdi. It may therefore be necessary for the application or service to start other activities to explicitly try to compensate this work. The application or coordinator may use this information to control the lifecycle of a jfdi.
